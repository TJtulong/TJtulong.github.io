<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="进程与线程进程概念程序：是一个指令序列。 为了方便操作系统管理，完成各程序并发执行，引入进程、进程实体的概念。  进程实体由程序段、数据段、PCB三部分组成。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，强调的是动态性。">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机操作系统--进程">
<meta property="og:url" content="http://yoursite.com/2019/08/08/计算机操作系统-进程/index.html">
<meta property="og:site_name" content="椰子皮&#39;s Blog">
<meta property="og:description" content="进程与线程进程概念程序：是一个指令序列。 为了方便操作系统管理，完成各程序并发执行，引入进程、进程实体的概念。  进程实体由程序段、数据段、PCB三部分组成。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，强调的是动态性。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/ProcessState.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E4%B8%89%E5%B1%82%E8%B0%83%E5%BA%A6.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg">
<meta property="og:image" content="http://picture.tjtulong.top/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.jpg">
<meta property="og:image" content="http://picture.tjtulong.top/%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.JPG">
<meta property="og:updated_time" content="2019-08-12T03:05:00.698Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机操作系统--进程">
<meta name="twitter:description" content="进程与线程进程概念程序：是一个指令序列。 为了方便操作系统管理，完成各程序并发执行，引入进程、进程实体的概念。  进程实体由程序段、数据段、PCB三部分组成。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，强调的是动态性。">
<meta name="twitter:image" content="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/08/计算机操作系统-进程/">





  <title>计算机操作系统--进程 | 椰子皮's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">椰子皮's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/计算机操作系统-进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tulong Xiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://picture.tjtulong.top/QQ%E5%9B%BE%E7%89%8720190515225418.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="椰子皮's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">计算机操作系统--进程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T23:21:34+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><strong>程序</strong>：是一个指令序列。</p>
<p>为了方便操作系统管理，完成各程序并发执行，引入进程、进程实体的概念。</p>
<p><img src="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.JPG" alt></p>
<p><strong>进程实体由程序段、数据段、PCB三部分组成。</strong></p>
<p><strong>进程控制块</strong> (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<font color="red">进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位，强调的是动态性。</font>

<p>进程的特征：动态性、并发性、独立性、异步性、结构性。</p>
<a id="more"></a>
<h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来，进程的组织方式有：</p>
<p><img src="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87.JPG" alt></p>
<h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><p><strong>进程的三种基本状态</strong>：</p>
<ol>
<li><strong>运行态</strong>（Running）：占有CPU，并在CPU上运行。</li>
<li><strong>就绪态</strong>（Ready）：已经拥有了除处理机之外所需要的资源，但由于没有空闲CPU，不能运行。</li>
<li><strong>阻塞态</strong>（Blocked）：因等待某一试件而不能运行。</li>
</ol>
<p>另外两种状态：</p>
<ol start="4">
<li><p><strong>创建态</strong>（New）</p>
</li>
<li><p><strong>终止态</strong>（Terminated）</p>
</li>
</ol>
<p><strong>进程状态的转换：</strong></p>
<p><img src="http://picture.tjtulong.top/ProcessState.png" alt></p>
<p><strong>运行态——&gt;阻塞态 是一种进程自身作出的主动行为</strong></p>
<p><strong>阻塞态——&gt;运行态 是不受进程自身控制的，是一种被动行为。</strong></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现<strong>进程状态转换</strong>等功能。</p>
<p>利用<strong>原语</strong>实现进程控制，原语的特点是执行期间不允许中断，采用“<strong>关中断指令</strong>”和“<strong>开中断指令</strong>”实现。</p>
<p>相关的原语包括：</p>
<ul>
<li>进程创建原语</li>
<li>进程撤销原语</li>
<li>进程的阻塞原语和唤醒原语</li>
<li>进程切换原语</li>
</ul>
<p><em>无论哪个原语，要做的无非三类事情:</em>  </p>
<ol>
<li><em>更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)</em> </li>
<li><em>将PCB插入合适的队列</em></li>
<li><em>分配/回收资源</em></li>
</ol>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信就是指进程之间的信息交换，各个进程拥有的内存地址空间相互独立，为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。进程之间的信息交换采用了以下方法。</p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p>两个进程对共享存储的访问必须是<strong>互斥</strong>的。</p>
<ol>
<li>基于数据结构的共享: 比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式；</li>
<li>基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制,  而不是操作系统。相比之下，这种共享方式速度更快，是一种<strong>高级通信方式</strong>。</li>
</ol>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件，是一个缓冲区。</p>
<p><img src="http://picture.tjtulong.top/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.JPG" alt></p>
<ol>
<li><p>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
</li>
<li><p>各进程要互斥地访问管道。</p>
</li>
<li><p>数据以字符流的形式写入管道，<strong>当管道写满时，写进程的 write()系统调用将被阻塞</strong>，等待读进程将数据取走。当读进程将数据全部取走后，<strong>管道变空，此时读进程的read()系统调用将被阻塞</strong>。</p>
</li>
<li><font color="red">如果没写满，就不允许读。如果没读空，就不允许写。</font></li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li>
</ol>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><img src="http://picture.tjtulong.top/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.JPG" alt></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>有的进程可能需要同时做很多事（QQ传文件、聊天、听歌），而传统的进程只能串行的执行一系列程序，为此引入了<strong>线程</strong>，来增加并发读。</p>
<font color="red">线程是轻量级的进程，线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程后，进程只作为除CPU外的系统资源分配单位，线程则作为处理机的基本分配单元。</font>

<p><strong>引入线程的变化：</strong></p>
<ul>
<li>进程是资源分配的基本单位，线程是调度的基本单位；</li>
<li>提高了并发性；</li>
<li>线程间并发，如果是同一进程内切换，则不需要切换进程环境，系统开销小。</li>
</ul>
<p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了<strong>多线程模型</strong>（三种）问题：</p>
<p><img src="http://picture.tjtulong.top/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.JPG" alt></p>
<p><img src="http://picture.tjtulong.top/%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.JPG" alt></p>
<p><img src="http://picture.tjtulong.top/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.JPG" alt></p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h2><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度</strong>就是从就绪队列中<strong>按照一定的算法选择一个进程并将处理机分配给它运行</strong>，以实现进程的并发执行。</p>
<p>进程的调度分为三个层次：</p>
<ol>
<li><strong>高级调度（作业调度）</strong>：按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建线程。</li>
<li><strong>中级调度（内存调度）</strong>：按照某种规则，从挂起队列中选择合适的进程将其数据调回内存。</li>
<li><strong>低级调度（进程调度）</strong>：按照某种规则，从就绪队列中选择一个进程为其分配处理机。</li>
</ol>
<p><img src="http://picture.tjtulong.top/%E4%B8%89%E5%B1%82%E8%B0%83%E5%BA%A6.JPG" alt></p>
<h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p>当前运行的进程<strong>主动放弃处理机</strong>：</p>
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（等待I/O）</li>
</ul>
<p>当前运行的进程<strong>被动放弃处理机</strong>：</p>
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如I/O中断）</li>
<li>有更优先级的进程进入就绪队列</li>
</ul>
<p>线程的切换过程包括对原来运行进程各种数据的保存，对新的进程各种数据的恢复。</p>
<font color="red">进程调度、切换是有代价的，并不是调度越频繁，并发度就越高。</font>

<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>评价调度算法的指标：</p>
<ul>
<li>CPU利用率</li>
<li>系统吞吐量</li>
<li>周转时间</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p><strong>长作业有可能会饿死</strong>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<p><strong>4 高响应比优先 highest response ratio next（HRRN）</strong></p>
<p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。</p>
<p><strong>响应比 = （等待时间 + 要求服务时间）/ 要求服务时间</strong></p>
<p>综合考虑了等待时间和运行时间(要求服务时间)</p>
<p>等待时间相同时，要求服务时间短的优先(SJF的优点)</p>
<p>要求服务时间相同时，等待时间长的优先(FCFS的优点)</p>
<p>对于长作业来说,随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
<h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>1 时间片轮转</strong></p>
<p>将所有就绪进程按<strong>FCFS</strong>的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的<strong>末尾</strong>，同时继续把CPU时间分配给<strong>队首</strong>的进程。是一种<strong>抢占式</strong>的调度方法。</p>
<p><img src="http://picture.tjtulong.top/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC.png" alt></p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果<strong>时间片太小，会导致进程切换得太频繁</strong>，在进程切换上就会花过多时间。</li>
<li>而如果<strong>时间片过长</strong>，那么实时性就不能得到保证，时间片轮转退化为先来先服务算法，增大进程的响应时间。</li>
</ul>
<p><strong>2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度，可能导致<strong>饥饿</strong>。</p>
<p>为了防止低优先级的进程永远等不到调度，可以<strong>随着时间的推移增加等待进程的优先级</strong>。</p>
<p>通常：</p>
<ul>
<li>系统进程优先级高于用户进程；</li>
<li>前台进程优先级高于后台进程</li>
<li>操作系统更偏好于I/O型进程（I/O繁忙型进程）</li>
</ul>
<p><strong>3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，<strong>它设置了多个队列，每个队列时间片大小都不同</strong>，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合，可能导致<strong>饥饿</strong>。</p>
<p><img src="http://picture.tjtulong.top/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png" alt></p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>并发带来了异步性，有时需要<strong>通过进程同步解决这种异步问题</strong>。</p>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>把一个时间段内只允许一个进程使用的资源称为<strong>临界资源</strong>。许多物理设备(比如像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。<strong>对临界资源的访问必须互斥地进行</strong>。互斥，亦称间接制约关系。进程互压指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束,释放该资源之后，另一个进程才能去访问临界资源。</p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下<strong>原则</strong>:</p>
<ol>
<li><p>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</p>
</li>
<li><p>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</p>
</li>
<li><p>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)；</p>
</li>
<li><p>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。 </p>
</li>
</ol>
<h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><p><img src="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0.JPG" alt></p>
<p><strong>Peterson算法</strong>使用<strong>两个控制变量flag与turn</strong>。其中flag[n]的值为真，表示ID号为n的进程希望进入该临界区。标量turn保存有权访问共享资源的进程的ID号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">P0:</span><br><span class="line">flag[0] = true;</span><br><span class="line">turn = 1;</span><br><span class="line">while (flag[1] == true &amp;&amp; turn == 1)</span><br><span class="line">&#123;</span><br><span class="line">// busy wait</span><br><span class="line">&#125; // critical section</span><br><span class="line">flag[0] = false; // end of critical section</span><br><span class="line"></span><br><span class="line">P1:</span><br><span class="line">flag[1] = true;</span><br><span class="line">turn = 0;</span><br><span class="line">while (flag[0] == true &amp;&amp; turn == 0)</span><br><span class="line">&#123;</span><br><span class="line">// busy wait</span><br><span class="line">&#125; // critical section</span><br><span class="line">flag[1] = false; // end of critical section</span><br></pre></td></tr></table></figure>
<h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><p><img src="http://picture.tjtulong.top/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0.JPG" alt></p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>前面的进程互斥的软硬件实现方法都无法实现“<strong>让权等待</strong>”。</p>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法：<strong>信号量控制</strong>。</p>
<p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p><u>信号量</u>其实就是一个变量(<strong>可以是一个整数，也可以是更复杂的记录型变量</strong>)，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。<u>原语</u>是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。</p>
<font color="red">一对原语：wait(S)原语和signal(s)原语，常简称为P、V操作(来自荷兰语 proberen和 verhogen)。</font>

<h3 id="整形信号量"><a href="#整形信号量" class="headerlink" title="整形信号量"></a>整形信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整型信号量存在的问题在于：<strong>不能满足让权等待问题</strong>。</p>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>通过运行态和阻塞态的转换实现了让权等待原则。</p>
<p><img src="http://picture.tjtulong.top/%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg" alt></p>
<h3 id="信号量机制实现同步"><a href="#信号量机制实现同步" class="headerlink" title="信号量机制实现同步"></a>信号量机制实现同步</h3><p><img src="http://picture.tjtulong.top/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.JPG" alt></p>
<h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个<strong>互斥量 mutex</strong> 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：<strong>empty 记录空缓冲区的数量，full 记录满缓冲区的数量</strong>。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong>不能先对缓冲区进行加锁，再测试信号量</strong>。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><h3 id="多生产者多消费者问题"><a href="#多生产者多消费者问题" class="headerlink" title="多生产者多消费者问题"></a>多生产者多消费者问题</h3><h3 id="读者问题"><a href="#读者问题" class="headerlink" title="读者问题"></a>读者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p><strong>一个整型变量</strong> count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能导致写者的饥饿问题，可以对再加一个P-V操作，避免写饥饿。</p>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><img src="http://picture.tjtulong.top/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.jpg" alt></p>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat();</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_two</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    test(LEFT);</span><br><span class="line">    test(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span> </span>&#123;         <span class="comment">// 尝试拿起两把筷子</span></span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p><strong>管程是一种特殊的软件模块</strong>，有这些部分组成，可以对比面向对象中的类:</p>
<ol>
<li><p>局部于管程的<strong>共享数据结构</strong>说明;</p>
</li>
<li><p>对该数据结构进行操作的<strong>一组过程</strong>;</p>
</li>
<li><p>对局部于管程的共享数据设置初始值的语句；</p>
</li>
<li>管程有一个名字。</li>
</ol>
<p>管程的<strong>基本特征</strong>：</p>
<ol>
<li><strong>局部于管程的数据只能被局部于管程的过程所访问</strong>；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据:</li>
<li><font color="red">每次仅允许一个进程在管程内执行某个内部过程（由编译器实现）。</font>

</li>
</ol>
<p>管程实现生产者消费者（实质是对P-V操作的封装）：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>Java中类似管程的概念便是sychronized。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源</strong>，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p>
<p>死锁、饥饿、死循环的区别：</p>
<p><img src="http://picture.tjtulong.top/%E6%AD%BB%E9%94%81%E9%A5%A5%E9%A5%BF%E6%AD%BB%E5%BE%AA%E7%8E%AF.JPG" alt></p>
<p>产生死锁必须同时满足一下<strong>四个条件</strong>，只要其中任一条件不成立，死锁就不会发生：</p>
<ul>
<li><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>什么时候发生死锁：</p>
<ol>
<li><p><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p>
</li>
<li><p><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2 分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
</li>
<li><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）。</li>
</ol>
<font color="red"><strong>对不可剥夺资源的不合理分配</strong>，可能导致死锁。</font>

<p>死锁的处理方法：</p>
<ol>
<li><p>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</p>
</li>
<li><p>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</p>
</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>从死锁的四个必要条件着手。</p>
<p><img src="http://picture.tjtulong.top/%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81.JPG" alt></p>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p><strong>安全序列：</strong></p>
<p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，只要找到一个安全序列，系统就是<strong>安全状态</strong>，安全状态可以有多个。如果分配了资源后，系统中找不到任何一个安全序列，系统就会进入了<strong>不安全状态</strong>，就可能发生死锁。</p>
<p>可以使用<strong>银行家算法</strong>来寻找安全序列：</p>
<p><strong>数据结构:</strong></p>
<p>长度为m的一维数组 Available表示还有多少可用资源；</p>
<p>n*m矩阵<strong>Max</strong>表示各进程对资源的最大需求数；</p>
<p>n*m矩阵<strong>Allocation</strong>表示已经给各进程分配了多少资源；</p>
<p>Max- Allocation=<strong>Need</strong>矩阵表示各进程最多还需要多少资源；</p>
<p>用长度为m的一位数组<strong>Request</strong>表示进程此次申请的各种资源数</p>
<p><strong>银行家算法步骤:</strong></p>
<ol>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探着分配，更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ol>
<p><strong>安全性算法步骤:</strong></p>
<p>检查当前的剩余可用资源是否能满足某个进程的最大需，如果可以，<strong>就把该进程加入安全序列</strong>，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p>
<h2 id="死锁的检验"><a href="#死锁的检验" class="headerlink" title="死锁的检验"></a>死锁的检验</h2><p>资源分配图：</p>
<p><img src="http://picture.tjtulong.top/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.JPG" alt></p>
<p>依次消除不与阻塞进程相连的边，直到无边可消，所谓不阻塞进程是指其申请的资源数还足够的进程，<strong>若资源分配图是不可完全简化的，说明发生了死锁。</strong></p>
<h2 id="消除死锁"><a href="#消除死锁" class="headerlink" title="消除死锁"></a>消除死锁</h2><ol>
<li><strong>资源剥夺法</strong>。挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而<strong>饥饿</strong>。</li>
<li><strong>撤销进程法(或称终止进程法)</strong>。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一且被终止可谓功亏一箦，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息,设置还原点。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/08/计算机操作系统-概述/" rel="next" title="计算机操作系统--概述">
                <i class="fa fa-chevron-left"></i> 计算机操作系统--概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/12/计算机操作系统-内存管理/" rel="prev" title="计算机操作系统--内存管理">
                计算机操作系统--内存管理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://picture.tjtulong.top/QQ%E5%9B%BE%E7%89%8720190515225418.jpg" alt="Tulong Xiao">
            
              <p class="site-author-name" itemprop="name">Tulong Xiao</p>
              <p class="site-description motion-element" itemprop="description">Almost Famous</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TJtulong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:TJtulong@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/2610493505/home" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/TJtulong" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-book"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.tongji.edu.cn/" title="同济大学" target="_blank">同济大学</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程与线程"><span class="nav-number">1.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程概念"><span class="nav-number">1.1.</span> <span class="nav-text">进程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的组织"><span class="nav-number">1.2.</span> <span class="nav-text">进程的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的状态与转换"><span class="nav-number">1.3.</span> <span class="nav-text">进程的状态与转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">1.4.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程通信"><span class="nav-number">1.5.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共享存储"><span class="nav-number">1.5.1.</span> <span class="nav-text">共享存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道通信"><span class="nav-number">1.5.2.</span> <span class="nav-text">管道通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递"><span class="nav-number">1.5.3.</span> <span class="nav-text">消息传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">1.6.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程调度"><span class="nav-number">2.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#调度的概念"><span class="nav-number">2.1.</span> <span class="nav-text">调度的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度的时机"><span class="nav-number">2.2.</span> <span class="nav-text">进程调度的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调度算法"><span class="nav-number">2.3.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#批处理系统"><span class="nav-number">2.3.1.</span> <span class="nav-text">批处理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交互式系统"><span class="nav-number">2.3.2.</span> <span class="nav-text">交互式系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程同步"><span class="nav-number">3.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥的软件实现方法"><span class="nav-number">3.1.</span> <span class="nav-text">进程互斥的软件实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程互斥的硬件实现方法"><span class="nav-number">3.2.</span> <span class="nav-text">进程互斥的硬件实现方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量机制"><span class="nav-number">3.3.</span> <span class="nav-text">信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整形信号量"><span class="nav-number">3.3.1.</span> <span class="nav-text">整形信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录型信号量"><span class="nav-number">3.3.2.</span> <span class="nav-text">记录型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量机制实现同步"><span class="nav-number">3.3.3.</span> <span class="nav-text">信号量机制实现同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典问题"><span class="nav-number">3.4.</span> <span class="nav-text">经典问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者问题"><span class="nav-number">3.4.1.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#吸烟者问题"><span class="nav-number">3.4.2.</span> <span class="nav-text">吸烟者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多生产者多消费者问题"><span class="nav-number">3.4.3.</span> <span class="nav-text">多生产者多消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读者问题"><span class="nav-number">3.4.4.</span> <span class="nav-text">读者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哲学家进餐问题"><span class="nav-number">3.4.5.</span> <span class="nav-text">哲学家进餐问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管程"><span class="nav-number">3.5.</span> <span class="nav-text">管程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#死锁"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预防死锁"><span class="nav-number">4.1.</span> <span class="nav-text">预防死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免死锁"><span class="nav-number">4.2.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的检验"><span class="nav-number">4.3.</span> <span class="nav-text">死锁的检验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消除死锁"><span class="nav-number">4.4.</span> <span class="nav-text">消除死锁</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tulong Xiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
