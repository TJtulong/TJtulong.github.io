<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="多线程,">










<meta name="description" content="Java内存模型Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到一致的内存访问效果。 线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译">
<meta name="keywords" content="多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发机制的底层实现">
<meta property="og:url" content="http://yoursite.com/2019/05/22/Java并发机制的底层实现/index.html">
<meta property="og:site_name" content="椰子皮&#39;s Blog">
<meta property="og:description" content="Java内存模型Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到一致的内存访问效果。 线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://picture.tjtulong.top/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.jpg">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92.png">
<meta property="og:image" content="http://picture.tjtulong.top/cacheline.jpg">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg">
<meta property="og:image" content="http://picture.tjtulong.top/MarkWord%E4%BF%A1%E6%81%AF.png">
<meta property="og:image" content="http://picture.tjtulong.top/MarkWord%E4%BF%A1%E6%81%AF2.png">
<meta property="og:image" content="http://picture.tjtulong.top/monitor.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%94%A4%E9%86%92%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E7%BC%96%E8%AF%91%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E5%86%99%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E8%AF%BB%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png">
<meta property="og:image" content="http://picture.tjtulong.top/CAS.png">
<meta property="og:image" content="http://picture.tjtulong.top/valueOffSet.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/getAndAddInt%E8%A7%A3%E9%87%8A.JPG">
<meta property="og:image" content="http://picture.tjtulong.top/ThreadLocal%E5%8E%9F%E7%90%86.png">
<meta property="og:updated_time" content="2020-04-06T08:19:32.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发机制的底层实现">
<meta name="twitter:description" content="Java内存模型Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到一致的内存访问效果。 线程之间的共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译">
<meta name="twitter:image" content="http://picture.tjtulong.top/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/22/Java并发机制的底层实现/">





  <title>Java并发机制的底层实现 | 椰子皮's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">椰子皮's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/22/Java并发机制的底层实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tulong Xiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://picture.tjtulong.top/QQ%E5%9B%BE%E7%89%8720190515225418.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="椰子皮's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java并发机制的底层实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-22T15:53:18+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  11.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  44
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>线程之间的共享变量存储在<strong>主内存</strong>(Main Memory)中，每个线程都有一个私有的<strong>本地内存</strong>(Local Memory)，本地内存中存储了该线程以读/写共享变量的<strong>副本</strong>。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>在计算机中，在读取速度上：硬盘 &lt; 内存 &lt; CPU，为解决CPU与内存速度相差过大的问题，在CPU和内存之间加入缓存cache。</p>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了<strong>高速缓存</strong>。</p>
<p>线程对变量的操作（读取赋值等）必须在工作内存中进行，首先概要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，<strong>不能直接操作主内存中的变量。</strong></p>
<p>加入高速缓存带来了一个新的问题：<strong>缓存一致性(MESI)</strong>。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议(Protocol)来解决这个问题。如果不行，需要加LOCK#锁<strong>锁总线</strong>。</p>
<p><img src="http://picture.tjtulong.top/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.jpg" alt></p>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<p><img src="http://picture.tjtulong.top/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png" alt></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java 内存模型定义了 <strong>8 个</strong>操作来完成主内存和工作内存的交互操作。</p>
<p><div align="center"> <img src="http://picture.tjtulong.top/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92.png" width="450px"> </div><br></p>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock：作用于主内存的变量</li>
</ul>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超线程（HT, Hyper-Threading）是英特尔研发的一种技术。</p>
<p>一个线程在执行时会占用CPU资源，其他线程想要得到执行就必须等待该线程将CPU资源让出。</p>
<p>利用超线程技术，模拟出的<strong>两个逻辑内核共享同一个CPU资源</strong>，所以同一时刻可以有两个线程都占用CPU资源，因此这两个线程都可以得到执行，这就是实现同一时间执行两个线程的并行操作。一个ALU(算术逻辑单元)对应多个PC与Register(寄存器)，所谓的<strong>四核八线程</strong>就是超线程实现的。</p>
<h2 id="cache-line"><a href="#cache-line" class="headerlink" title="cache  line"></a>cache  line</h2><p><img src="http://picture.tjtulong.top/cacheline.jpg" width="600" height="高度" alt="图片名称" align="center"></p>
<p>CPU在读内存时一次读一个<strong>块（cache line 缓存行），64字节</strong>，因为读取一个数据后往往会读它相邻的数据。</p>
<p><strong>缓存行对齐写法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLinePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 占据7 * 8个字节，保证了arr[0].x，arr[1].x在不同的cache line，避免相互干扰，加快运行速度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并发框架Disruptor就是采用这种写法。</p>
<p><strong>缓存一致性MESI</strong>可参考：<a href="https://blog.csdn.net/zlt995768025/article/details/81275373" target="_blank" rel="noopener">https://blog.csdn.net/zlt995768025/article/details/81275373</a></p>
<p>它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行<strong>置为无效状态</strong>，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="http://picture.tjtulong.top/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt></p>
<ul>
<li><p><strong>Mark Word</strong>：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占<strong>8字节</strong>；</p>
</li>
<li><p><strong>Class Pointer</strong>：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占<strong>4字节</strong>，在64位系统中占8字节；</p>
</li>
<li><p><strong>Length</strong>：如果是数组对象，还有一个保存数组长度的空间，占4个字节；</p>
</li>
<li><p><strong>对象实际数据</strong>包括了对象的所有成员变量，其大小由各个成员变量的大小决定；</p>
</li>
<li><p><strong>对齐填充：</strong>Java对象占用空间是<strong>8字节对齐</strong>的，即所有Java对象占用bytes数必须是8的倍数。例如，一个包含两个属性的对象：int和byte，这个对象需要占用8+4+1=13个字节，这时就需要加上大小为3字节的padding进行8字节对齐，最终占用大小为16个字节。</p>
</li>
</ul>
<p>JVM启动参数<code>-XX:+UseCompressedClassPointer</code>会把ClassPointer64位指针的8字节压缩为4字节。<code>-XX:+UseCompressedOops</code>会把指向对象的64位指针的8字节压缩为4字节。因此对象头一共12个字节。</p>
<p><em>原因可参考：<a href="https://blog.csdn.net/zjerryj/article/details/77206928" target="_blank" rel="noopener">https://blog.csdn.net/zjerryj/article/details/77206928</a></em></p>
<p>使用工具<strong>JOL</strong>（Java Object Layout）查看</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查看Object对象的内存布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">// 输出内存布局</span></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   <span class="built_in">TYPE</span> DESCRIPTION   VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)    <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)    <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)    e5 <span class="number">01</span> <span class="number">00</span> <span class="number">20</span> (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536871397</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>
<p><strong>因此一个Object对象占16字节。</strong></p>
<p>当给一个对象加锁时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(ClassLayout.parseInstance(o).toPrintable());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   <span class="built_in">TYPE</span> DESCRIPTION    VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)     e8 f0 <span class="number">67</span> <span class="number">02</span> (<span class="number">11101000</span> <span class="number">11110000</span> <span class="number">01100111</span> <span class="number">00000010</span>) (<span class="number">40366312</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)     <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)     e5 <span class="number">01</span> <span class="number">00</span> <span class="number">20</span> (<span class="number">11100101</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536871397</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>   (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>
<p>可见MarkWord发生了变化</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>JSR-133使用happens-before的概念来阐述操作之间的内存可见性，让线程遵守happens-before原则来解决多线程的可见性。如果一个操作 happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见</p>
<p>注：两个操作之间有happens-before关系，并不意味着前一个操作必须在后一个操作之前执行，仅仅要求前一个操作对后一个操作可见。</p>
<p><strong>happens-before规则：</strong></p>
<ol>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作，编译器不会对存在数据依赖关系的操作重排序(as-if-serial语义)。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()(启动线程B)，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回,那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ol>
<h1 id="sychronized实现原理"><a href="#sychronized实现原理" class="headerlink" title="sychronized实现原理"></a>sychronized实现原理</h1><h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><p>对于同一问题的处理，并不一定是创建的线程数量越多，执行越快，这是由于<strong>线程有创建和上下文切换的开销</strong>。而锁的上下文消耗尤为严重，因此JDK6对锁进行了优化。</p>
<p>这里的锁优化主要是指JVM对synchronized的优化。</p>
<p>JDK 1.6引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：<strong>无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated</strong>）。这几个状态会随着竞争逐渐升级，<strong>锁可以升级但不能降级</strong>。</p>
<p>锁升级对应着<strong>对象头</strong>的变化：</p>
<p><img src="http://picture.tjtulong.top/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg" alt="enter description here"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>HotSpot的作者发现：<strong>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p>
<p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p>
<p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时<strong>撤销偏向</strong>（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁又称为<strong>自旋锁、无锁、自适应自旋</strong>，运行在用户态。</p>
<p>下图左侧是一个线程的虚拟机栈，其中有一部分称为<strong>Lock Record</strong>的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的Mark Word。而右侧就是一个锁对象，包含了Mark Word和其它信息。</p>
<p><img src="http://picture.tjtulong.top/MarkWord%E4%BF%A1%E6%81%AF.png" width="600" height="高度" alt="图片名称" align="center"></p>
<p>轻量级锁是相对于传统的重量级锁而言，它<strong>使用CAS操作来避免重量级锁使用互斥量的开销</strong>。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用CAS操作进行同步，如果CAS失败了再改用互斥量进行同步。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建Lock Record，然后<strong>使用 CAS 操作将对象的Mark Word更新为Lock Record 指针</strong>。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的Mark Word的锁标记变为 00，表示该对象处于轻量级锁状态。</p>
<p><img src="http://picture.tjtulong.top/MarkWord%E4%BF%A1%E6%81%AF2.png" width="490" height="高度" alt="图片名称" align="center"></p>
<p>如果 CAS 操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占。</p>
<p><strong>竞争加剧：</strong>有线程超过十次自旋，<code>-XX:PreBlockSpin</code>，或者自旋线程数超过CPU核数的一半；1.6以后，JVM加入了自适应自旋Adapative Self Spinning，由JVM自己控制。</p>
<p>当竞争加剧<strong>膨胀为重量级锁</strong>。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于<strong>底层操作系统的Mutex Lock</strong>实现，操作系统实现线程之间的切换需要<strong>从用户态到内核态的切换，切换成本非常高</strong>。</p>
<p><strong>每一个重量级锁(内核态)都维护着一个队列，没有轮到执行的线程不消耗任何CPU，处于阻塞状态。</strong>但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。</p>
<p>在Java虚拟机(HotSpot)中，<strong>monitor</strong>是由ObjectMonitor实现的（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的），<strong>ObjectMonitor</strong>中有几个关键属性：</p>
<ul>
<li>_owner：指向持有ObjectMonitor对象的线程；</li>
<li><strong>_cxq（竞争队列）</strong>：是一个单向链表，被挂起线程等待重新竞争锁的链表；</li>
<li>_WaitSet：存放处于wait状态的线程队列；</li>
<li><strong>_EntryList（锁候选者列表）</strong>：存放处于等待锁block状态的线程队列，EntryList是一个双向链表。当EntryList为空，cxq不为空，Owener会在unlock时，将cxq中的数据移动到EntryList。并指定EntryList列表头的第一个线程为OnDeck线程。在cxq中的队列可以继续自旋等待锁，若达到自旋的阈值仍未获取到锁则会调用park方法挂起。而EntryList中的线程都是被挂起的线程。</li>
<li>_recursions：锁的重入次数；</li>
<li>_count：用来记录该线程获取锁的次数；</li>
</ul>
<p>当一个线程参与锁的竞争时，通过CAS尝试把monitor的<code>_owner</code>字段设置为当前线程（底层依然是<code>lock comxchg</code>），失败后通过自旋执行<code>ObjectMonitor::EnterI</code>方法等待锁的释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br></pre></td></tr></table></figure>
<p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个<code>ObjectWaiter</code>对象插入到cxq的队列的队首，自旋一段时间然后调用<code>park</code>函数挂起当前线程。<em>JDK的<code>ReentrantLock</code>底层也是用该方法挂起线程的。</em></p>
<p>当多个线程同时访问一段同步代码时，首先会进入<strong>_cxq</strong>与<strong>_EntryList</strong>队列中，当某个线程获取到对象的monitor后进入<strong>_Owner</strong>区域并把monitor中的<strong>_owner</strong>变量设置为当前线程，同时monitor中的计数器count加1，即获得对象锁。若持有monitor的线程调用wait()方法，将释放当前持有的monitor，<strong>_owner</strong>变量恢复为null，<strong>_count</strong>自减1，同时该线程进入<strong>_WaitSet</strong>集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。</p>
<p><img src="http://picture.tjtulong.top/monitor.png" alt></p>
<p><strong>锁的释放：</strong></p>
<p>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过<code>ObjectMonitor::ExitEpilog</code>方法<strong>唤醒</strong>该节点封装的线程，唤醒操作最终由<code>unpark</code>完成。</p>
<p><img src="http://picture.tjtulong.top/%E5%94%A4%E9%86%92%E6%B5%81%E7%A8%8B.png" width="500" height="高度" alt="图片名称" align="center"></p>
<p><strong>获取monitor总结</strong></p>
<ol>
<li>线程首先通过CAS尝试将monitor的owner设置为自己；</li>
<li>若执行成功，则判断该线程是不是重入。若是重入，则执行recursions + 1,否则执行recursions = 1；</li>
<li>若失败，则将自己封装为ObjectWaiter，并通过CAS加入到cxq中。</li>
</ol>
<p><strong>释放monitor总结</strong></p>
<ol>
<li>判断是否为重量级锁，是则继续流程；</li>
<li>recursions - 1；</li>
<li>根据<strong>不同的策略</strong>设置一个OnDeckThread。</li>
</ol>
<p><em>参考：</em></p>
<ul>
<li><a href="https://www.jianshu.com/p/60ea4b0d4487" target="_blank" rel="noopener">Java锁事之重量级锁</a></li>
<li><a href="https://www.jianshu.com/p/435c20a64da1" target="_blank" rel="noopener">synchronized原理及优化</a></li>
<li><a href="https://blog.51cto.com/14440216/2427707?source=dra" target="_blank" rel="noopener">死磕Synchronized底层实现–重量级锁</a></li>
<li><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></li>
</ul>
<h3 id="cxq与EntryList"><a href="#cxq与EntryList" class="headerlink" title="cxq与EntryList"></a>cxq与EntryList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----测试开始----"</span>);</span><br><span class="line"></span><br><span class="line">        FairDemo fd = <span class="keyword">new</span> FairDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                fd.fair();</span><br><span class="line">            &#125;, <span class="string">"Thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fair</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"开始运行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----测试开始----</span><br><span class="line">Thread <span class="number">1</span>开始运行</span><br><span class="line">Thread <span class="number">10</span>开始运行</span><br><span class="line">Thread <span class="number">9</span>开始运行</span><br><span class="line">Thread <span class="number">8</span>开始运行</span><br><span class="line">Thread <span class="number">7</span>开始运行</span><br><span class="line">Thread <span class="number">6</span>开始运行</span><br><span class="line">Thread <span class="number">5</span>开始运行</span><br><span class="line">Thread <span class="number">4</span>开始运行</span><br><span class="line">Thread <span class="number">3</span>开始运行</span><br><span class="line">Thread <span class="number">2</span>开始运行</span><br></pre></td></tr></table></figure>
<p>可以看出后来的线程反而先获得了锁，即默认策略下（QMode=0），在线程1释放锁后一定是线程10先获得锁。因为在获取锁时，是将当前线程插入到cxq的<strong>头部</strong>，而释放锁时，默认策略是：如果EntryList为空，则将cxq中的元素按原有顺序插入到到EntryList，并唤醒第一个线程。也就是<strong>当EntryList为空时，是后来的线程先获取锁</strong>。这点JDK中的Lock机制是不一样的。</p>
<h3 id="偏向锁、轻量级锁的状态转换"><a href="#偏向锁、轻量级锁的状态转换" class="headerlink" title="偏向锁、轻量级锁的状态转换"></a>偏向锁、轻量级锁的状态转换</h3><p><img src="http://picture.tjtulong.top/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="enter description here"></p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。<strong>自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态</strong>。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p>
<p>在JDK1.6中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指<strong>对于被检测出不可能存在竞争的共享数据的锁进行消除</strong>。</p>
<p>锁消除主要是通过<strong>逃逸分析</strong>来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的<strong>动态作用域被限制在 <code>concatString()</code>方法内部</strong>。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p>
<p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p>
<p><strong>总结Synchronized的执行过程：</strong></p>
<ol>
<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁 。</li>
<li>如果不是，CAS用当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1 。</li>
<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁 。</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li>如果自旋成功则依然处于轻量级状态。</li>
<li>如果自旋一定时间后未成功，则升级为重量级锁。</li>
</ol>
<p>[参考资料] <a href="https://www.jianshu.com/p/2bd4a3c8c30c" target="_blank" rel="noopener">https://www.jianshu.com/p/2bd4a3c8c30c</a></p>
<h2 id="Sychronized的底层实现"><a href="#Sychronized的底层实现" class="headerlink" title="Sychronized的底层实现"></a>Sychronized的底层实现</h2><p>sychronized的实现过程：</p>
<ol>
<li>Java代码：sychronized</li>
<li>字节码层面：monitorenter + monitorexit(同步代码块)、ACC_SYNCHRONIZED(同步方法)</li>
<li>执行过程中自动升级</li>
<li>汇编：lock comxchg指令</li>
<li>操作系统：Mutex Lock</li>
</ol>
<h2 id="Synchronized与Lock的对比"><a href="#Synchronized与Lock的对比" class="headerlink" title="Synchronized与Lock的对比"></a>Synchronized与Lock的对比</h2><p><strong>原始构成：</strong></p>
<ul>
<li><p>synchronized是<strong>关键字</strong>，属于JVM层面；</p>
<p>sychronized底层是通过monitor对象来完成，wait/notify等方法也依赖于monitor对象，只有在同步或方法中才能调用wait/notify等方法。<strong>monitorenter  —-&gt;  monitorexit</strong></p>
</li>
<li><p>Lock是<strong>具体类</strong>，是API层面的锁。</p>
</li>
</ul>
<p><strong>使用方法：</strong></p>
<ul>
<li>sychronized不需要用户取手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用；</li>
<li>ReentrantLock则需要用户去手动释放锁，若没有主动释放锁，就有可能导致出现死锁现象，需要<code>lock()</code>和<code>unlock()</code>方法配合try/finally语句块来完成。</li>
</ul>
<p><strong>等待是否可中断：</strong></p>
<ul>
<li>synchronized不可中断，除非抛出异常或者正常运行完成；</li>
<li>ReentrantLock可中断，设置超时方法<code>tryLock(long timeout, TimeUnit unit)</code>，或者<code>lockInterruptibly()</code>放代码块中，调用<code>interrupt()</code>方法可中断。</li>
</ul>
<p><strong>加锁是否公平：</strong></p>
<ul>
<li>synchronized非公平锁；</li>
<li>ReentrantLock两者都可以，默认公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁。</li>
</ul>
<p><strong>锁绑定多个条件Condition：</strong></p>
<ul>
<li>synchronized无法绑定多个条件；</li>
<li>ReentrantLock用来实现分组唤醒线程，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程（notify）要么唤醒全部线程（notifyAll）。</li>
</ul>
<p><strong>执行顺序：</strong></p>
<ul>
<li>Synchronized在特定的情况下<strong>对于已经在等待的线程</strong>是后来的线程先获得锁（上文有说），而ReentrantLock对于<strong>已经在等待的线程</strong>一定是先来的线程先获得锁；</li>
</ul>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>volatile是多线程的一种<strong>轻量级</strong>的同步机制，<strong>保证可见性，禁止指令重排，但不保证原子性</strong>。</p>
<h2 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>volatile保证了线程之间的可见性，也就是对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证volatile的可见性</span></span><br><span class="line">        visibilityByVolatile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visibilityByVolatile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                myData.addToSixty();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t update value:"</span> + myData.num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个线程是main线程</span></span><br><span class="line">        <span class="keyword">while</span> (myData.num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果myData的num一直为零，main线程一直在这里循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t mission is over, num value is "</span> + myData.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int num = 0; 不加volatile主线程进入死循环</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToSixty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p.s. 对于实现了缓存一致性协议的CPU，MESI其实已经保证了多核内存间的可见性。这时候volatile是不是就没用了呢？答案肯定是volatile依然有用：</p>
<ul>
<li><p>第一：代码运行的cpu是不是实现了MESI协议是不一定的；</p>
</li>
<li><p>第二，就算在实现了MESI的CPU上，volatile一样不可或缺。除了禁止指令重排序的作用外，由于MESI只是保证了L1-3cache之间的可见性，但是CPU和L1之间还有像storebuffer之类的缓存，而volatile规范保证了对它修饰的变量的写指令会使得当前cpu所有缓存写到被mesi保证可见性的L1-3cache中。</p>
</li>
</ul>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p><strong>原子性</strong>：不可分割，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败。</p>
<p>对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</p>
<p>例如多线程<code>num++</code>1000次，最后<code>num</code>会小于1000，出现写覆盖。</p>
<p>因为实际上一个<code>++</code>操作在字节码中分为三步，不是一个原子操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getfield #2</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">putfield #2</span><br></pre></td></tr></table></figure>
<h3 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h3><p>volatile还可以禁止代码重排，对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p>
<p>在计算机执行程序时，为了提高性能，编译器和处理器常常会对<strong>指令做重拍</strong>，一般分以下三种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源代码 --&gt; id1[&quot;编译器优化的重排&quot;]</span><br><span class="line">id1 --&gt; id2[指令并行的重排]</span><br><span class="line">id2 --&gt; id3[内存系统的重排]</span><br><span class="line">id3 --&gt; 最终执行的指令</span><br></pre></td></tr></table></figure>
<p><strong>单线程</strong>环境里面确保程序最终执行结果和代码顺序执行的结果一致，处理器在进行重排顺序是必须要考虑指令之间的<strong>数据依赖性</strong>，多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性时无法确定的，结果无法预测。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">11</span>; <span class="comment">// 语句1</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">12</span>; <span class="comment">// 语句2</span></span><br><span class="line">    x = x + <span class="number">5</span>； <span class="comment">// 语句3</span></span><br><span class="line">    y = x * x; <span class="comment">//语句4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在保证数据依赖性的前提下可能的执行顺序为：<strong>1234、2134、1324</strong></p>
<p><strong>代码重排案例一：</strong></p>
<p>声明变量：<code>int a,b,x,y=0</code></p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>结果</td>
<td>x = 0      y=0</td>
</tr>
</tbody>
</table>
<p>如果编译器对这段程序代码执行重排优化后，可能出现如下情况：</p>
<table>
<thead>
<tr>
<th>线程1</th>
<th>线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td>b = 1;</td>
<td>a = 2;</td>
</tr>
<tr>
<td>x = a;</td>
<td>y = b;</td>
</tr>
<tr>
<td>结果</td>
<td>x = 2      y=1</td>
</tr>
</tbody>
</table>
<p>这个结果说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量依赖性是无法确定的。</p>
<p><strong>代码重排案例二：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReSortSeqDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 语句1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 语句2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            a = a + <span class="number">5</span>; <span class="comment">//语句1如果与语句2重排，结果完全不同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><ul>
<li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存；</li>
<li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</li>
</ul>
<h2 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h2><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>内存屏障</strong>（Memory Barrier）又称内存栅栏，是一个CPU指令，他的作用有两个：</p>
<ol>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li>
</ol>
<p>由于编译器和处理器都能执行指令重排优化，如果在这之前插入一条内存屏障则会告诉编译器和CPU，不管什么指令都不能和这条Memory  Barrier指令重排顺序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令重排序</strong>。内存屏障另外一个作用是<strong>强制刷出各种CPU的缓存数据</strong>，因此任何CPU上的线程都能读取到这些数据的最新版本。</p>
<ul>
<li><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；</p>
</li>
<li><p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p>
</li>
</ul>
<p>为了实现volatile内存语义，JMM会分别限制<strong>编译器重排序和处理器重排序</strong>。</p>
<h3 id="编译器重排序"><a href="#编译器重排序" class="headerlink" title="编译器重排序"></a>编译器重排序</h3><p><img src="http://picture.tjtulong.top/%E7%BC%96%E8%AF%91%E5%99%A8%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="enter description here"></p>
<ul>
<li>当第二个操作为volatile写操作时,不管第一个操作是什么(普通读写或者volatile读写),都不能进行重排序。这个规则确保volatile写之前的所有操作都不会被重排序到volatile写之后;</li>
<li>当第一个操作为volatile读操作时,不管第二个操作是什么,都不能进行重排序。这个规则确保volatile读之后的所有操作都不会被重排序到volatile读之前;</li>
<li>当第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序。</li>
</ul>
<h3 id="处理器重排序"><a href="#处理器重排序" class="headerlink" title="处理器重排序"></a>处理器重排序</h3><p>编译器在生成字节码时，会在指令中<strong>插入内存屏障</strong>来禁止特定类型的处理器重排序，volatile的内存屏障策略非常<strong>严格保守</strong>：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p><img src="http://picture.tjtulong.top/%E5%86%99%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" width="500" height="高度" alt="图片名称" align="center"></p>
<p><img src="http://picture.tjtulong.top/%E8%AF%BB%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" width="500" height="高度" alt="图片名称" align="center"></p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ol>
<li>Java代码中的volatile；</li>
<li>字节码中的标记：ACC_VOLATILE；</li>
<li>JVM按照JSR(Java规范)加入内存屏障；</li>
<li>hotspot实现：不是加内存屏障，而是直接用lock锁总线（保证可移植性）。</li>
</ol>
<p><code>lock</code>指令的作用：</p>
<ul>
<li><p>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放(效率太低)，不过实际后来的处理器都采用<strong>锁缓存行</strong>替代锁总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存。</p>
</li>
<li><p>lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据，<strong>MESI缓存一致性协议+CPU总线嗅探机制(监听)</strong></p>
</li>
<li><p>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两边的指令重排序</p>
</li>
</ul>
<p>当写两条线程Thread-A与Threab-B同时操作主存中的一个volatile变量i时，Thread-A写了变量i，那么：</p>
<ul>
<li>Thread-A发出LOCK#指令；</li>
<li>发出的LOCK#指令锁总线（或锁缓存行），同时让Thread-B高速缓存中的缓存行内容失效；</li>
<li>Thread-A向主存回写最新修改的i；</li>
</ul>
<p>Thread-B读取变量i，那么：</p>
<ul>
<li>Thread-B发现对应地址的缓存行被锁了，等待锁的释放，缓存一致性协议会保证它读取到最新的值。</li>
</ul>
<p><em>详细可参考：<a href="https://blog.csdn.net/qq_26222859/article/details/52235930" target="_blank" rel="noopener">https://blog.csdn.net/qq_26222859/article/details/52235930</a></em></p>
<h2 id="DCL单例模式"><a href="#DCL单例模式" class="headerlink" title="DCL单例模式"></a>DCL单例模式</h2><p>Double Check Lock双端检索机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是<strong>分为三步执行</strong>：</p>
<ol>
<li>为对象分配内存空间allocate()</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，<strong>线程 T<sub>1</sub> 执行了 1 和 3，此时 T<sub>2</sub> 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化(半初始化)。</strong></p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><p>synchronized关键字和volatile关键字比较：</p>
<ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字的场景还是更多一些。</li>
<li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li>
<li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li>
<li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CompareAndSwap"><a href="#CompareAndSwap" class="headerlink" title="CompareAndSwap"></a>CompareAndSwap</h2><p>CAS是英文单词<strong>CompareAndSwap</strong>的缩写，中文意思是：比较并替换。它是一条CPU并发原语。CAS需要有3个操作数：<strong>内存地址V，旧的预期值A，即将要更新的目标值B</strong>。</p>
<p>CAS指令执行时，<strong>当且仅当内存地址V当中的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作（依靠UnSafe类），此操作具有volative读和写的内存操作</strong>。</p>
<p>Java并发包原子操作类（Atomic开头）就是采用CAS机制。</p>
<p><code>atomicInteger.compareAndSet(5, 2019)</code></p>
<p><img src="http://picture.tjtulong.top/CAS.png" width="450" height="高度" alt="图片名称" align="left"></p>
<p>从思想上来说，<strong>synchronized属于悲观锁</strong>，悲观的认为程序中的并发情况严重，所以严防死守，<strong>CAS属于乐观锁</strong>，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。</p>
<p>在Java中除了上面提到的Atomic系列类，以及Lock系列类夺得底层实现，甚至在JAVA1.6以上版本，Synchronized转变为重量级锁之前，也会采用CAS机制。</p>
<h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p>CAS调用的是<strong>sun.misc.Unsafe类</strong>(rt.jar包)中的方法，为native方法。</p>
<p>对于<code>atomicInteger.getAndIncrement()</code>方法，底层为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    this 表示当前对象</span></span><br><span class="line"><span class="comment">    valueoffset（Long） 表示内存偏移量</span></span><br><span class="line"><span class="comment">    1 表示每次增加1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取<code>valueOffset</code>的方法：</strong></p>
<p><img src="http://picture.tjtulong.top/valueOffSet.JPG" alt></p>
<p>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现<strong>CAS汇编指令</strong>。这是一种完全依赖于硬件的功能，通过它实现了原子操作。由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，<strong>并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题。</strong></p>
<p>UnSafe类中的<code>getAndAddInt</code>方法：</p>
<p><img src="http://picture.tjtulong.top/getAndAddInt%E8%A7%A3%E9%87%8A.JPG" alt></p>
<p>其中<code>this.compareAndSwapInt</code>为一个native方法，具有原子性，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  </span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);  </span><br><span class="line">  oop p = JNIHandles::resolve(obj);  </span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);  </span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;  </span><br><span class="line">UNSAFE_END  </span><br><span class="line"><span class="comment">//通过Atomic::cmpxchg实现比较替换，其中参数x是即将更新的值，参数e是原内存的值</span></span><br></pre></td></tr></table></figure>
<p>核心方法是<strong>compxchg</strong>，这个方法所属的类文件是在OS_CPU目录下面，由此可以看出这个类是和CPU操作有关，进入代码如下（汇编指令）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint Atomic::cmpxchg (jint exchange_value, <span class="keyword">volatile</span> jint* dest,jint compare_value) &#123;  </span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange  </span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();  </span><br><span class="line">  __asm &#123;  </span><br><span class="line">    mov edx, dest  </span><br><span class="line">    mov ecx, exchange_value  </span><br><span class="line">    mov eax, compare_value  </span><br><span class="line">    LOCK_IF_MP(mp)  </span><br><span class="line">    cmpxchg dword ptr [edx], ecx  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面都是<strong>汇编指令</strong>，可以看到<strong>LOCK_IF_MP</strong>(如果多个CPU则加锁)也有锁指令实现的原子操作，其实CAS也算是有锁操作，只不过是由CPU来触发，比synchronized性能好的多。</p>
<p>核心：<code>lock cmpxchg</code> 指令</p>
<p>在硬件上：<code>lock</code>指令在执行后面指令的时候锁定一个北桥信号，不采用锁总线的方式。</p>
<p>[参考资料] <a href="https://blog.csdn.net/v123411739/article/details/79561458" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/79561458</a></p>
<h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p>
<ul>
<li><strong>循环时间长开销很大：</strong><br>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</li>
<li><strong>只能保证一个共享变量的原子操作：</strong><br>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</li>
<li><strong>ABA问题：</strong><br>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？<br>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的ABA问题Java并发包为了解决这个问题，提供了一个带有标记的原子引用类<code>AtomicStampedReference</code>，它可以通过控制变量值的<strong>版本</strong>来保证CAS的正确性。因此，在使用CAS前要考虑清楚ABA问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</li>
</ul>
<h2 id="ABA问题解决"><a href="#ABA问题解决" class="headerlink" title="ABA问题解决"></a>ABA问题解决</h2><p><strong>原子引用类AtomicReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicRefrenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">22</span>);</span><br><span class="line">        User l4 = <span class="keyword">new</span> User(<span class="string">"李四"</span>, <span class="number">23</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">"\t"</span> + atomicReference.get().toString()); <span class="comment">// true	User(userName=李四, age=23)</span></span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + <span class="string">"\t"</span> + atomicReference.get().toString()); <span class="comment">// false	User(userName=李四, age=23)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AtomicStampedReference：时间戳版本号解决ABA问题</strong></p>
<p>AtomicStampedReference它内部不仅维护了对象值，还维护了一个时间戳（我这里把它称为时间戳，实际上它可以使任何一个<strong>整数</strong>，它使用整数来表示状态值）。当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳。当AtomicStampedReference设置对象值时，对象值以及时间戳都必须满足期望值，写入才会成功。因此，即使对象值被反复读写，写回原值，只要时间戳发生变化，就能防止不恰当的写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ABA问题解决</span></span><br><span class="line"><span class="comment"> * AtomicStampedReference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=====以下时ABA问题的产生====="</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">"Thread 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//保证线程1完成一次ABA操作</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t"</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">"Thread 2"</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=====以下时ABA问题的解决====="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t第1次版本号"</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t第2次版本号"</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t第3次版本号"</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">"Thread 3"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t第1次版本号"</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t修改是否成功"</span> + result + <span class="string">"\t当前最新实际版本号："</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t当前最新实际值："</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">"Thread 4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">=====以下时ABA问题的产生=====</span><br><span class="line"><span class="keyword">true</span>	<span class="number">2019</span></span><br><span class="line">=====以下时ABA问题的解决=====</span><br><span class="line">Thread <span class="number">3</span>	第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">4</span>	第<span class="number">1</span>次版本号<span class="number">1</span></span><br><span class="line">Thread <span class="number">3</span>	第<span class="number">2</span>次版本号<span class="number">2</span></span><br><span class="line">Thread <span class="number">3</span>	第<span class="number">3</span>次版本号<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>	修改是否成功<span class="keyword">false</span>	当前最新实际版本号：<span class="number">3</span></span><br><span class="line">Thread <span class="number">4</span>	当前最新实际值：<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h1 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h1><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><p>公平锁就是线程先来后到、非公平锁就是允许线程加塞</p>
<p><code>Lock lock = new ReentrantLock(Boolean fair);</code> <strong>默认为非公平</strong>。</p>
<ul>
<li><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，类似排队。</li>
<li><strong>非公平锁</strong>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程优先获取锁，在高并发的情况下，有可能会造成<strong>优先级反转或者饥饿现象</strong>。</li>
</ul>
<p><strong>二者区别：</strong></p>
<ul>
<li><p><strong>公平锁</strong>：Threads acquire  a fair lock in the order in which they requested it</p>
<p>公平锁，就是很公平，在并发环境中，每个线程在获取锁时，会先查看此锁维护的等待队列，如果为空，或者当前线程就是等待队列的第一个，就占有锁，否则就会加入到<strong>等待队列</strong>中，以后会按照<strong>FIFO</strong>的规则从队列中取到当前线程。</p>
</li>
<li><p><strong>非公平锁</strong>：a nonfair lock permits barging: threads  requesting a lock can jump ahead of the queue of waiting threads if the  lock happens to be available when it is requested.</p>
<p>非公平锁比较粗鲁，<strong>直接尝试占有锁</strong>，如果尝试失败，就再采用类似公平锁那种方式。</p>
</li>
</ul>
<p>对ReentrantLock而言，通过构造函数指定该锁默认是非公平锁，<strong>非公平锁的优点在于吞吐量比公平锁大</strong>。</p>
<p><strong>Synchronized是一种非公平锁。</strong></p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁（也叫作递归锁），指的时同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。可重入锁最大的作用是避免死锁。</p>
<p><strong>ReentrantLock/Synchronized 就是典型的可重入锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mobile mobile = <span class="keyword">new</span> Mobile();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(mobile).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mobile</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock(); <span class="comment">// 两把锁照样可以正常运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked get()"</span>);</span><br><span class="line">            set(); <span class="comment">// set方法中的锁可重入，可以继续执行</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked set()"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自旋锁-1"><a href="#自旋锁-1" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是<strong>采用循环的方式去尝试获取锁</strong>，这样的<strong>好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</strong></p>
<p><strong>手写一个自旋锁：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现自旋锁</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取知道成功位置，没有类似wait的阻塞</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，知道A释放锁后B随后抢到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 自己通过自旋方法生成的锁</span></span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">"Thread 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.mylock();</span><br><span class="line">            spinLockDemo.myUnlock();</span><br><span class="line">        &#125;, <span class="string">"Thread 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t come in"</span>);</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// CAS解锁</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t invoked myunlock()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul>
<li><p><strong>独占锁(写锁)</strong>：指该锁一次只能被一个线程所持有，对ReentrantLock和Synchronized而言都是独占锁；</p>
</li>
<li><p><strong>共享锁(读锁)</strong>：只该锁可被多个线程所持有；</p>
<p><strong>ReentrantReadWriteLock</strong>其读锁是共享锁，写锁是独占锁</p>
</li>
<li><p><strong>互斥锁</strong>：读锁的共享锁可以保证并发读是非常高效的，读写、写读、写写的过程是互斥的。</p>
</li>
</ul>
<p>多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。但是如果有一个线程象取写共享资源来，就不应该由其他线程对资源进行读或写。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整个过程必须是一个完整的统一体，中间不许被分割，不许被打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写锁 独占锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读锁 共享锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ThreadLocal的原理"><a href="#ThreadLocal的原理" class="headerlink" title="ThreadLocal的原理"></a>ThreadLocal的原理</h1><p>Thread为每个线程维护了ThreadLocalMap这么一个Map，在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是每个<strong>ThreadLocal对象的弱引用</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</p>
<p><img src="http://picture.tjtulong.top/ThreadLocal%E5%8E%9F%E7%90%86.png" alt></p>
<p>创建线程时，会将父线程的<code>InheritableThreadLocal</code>复制过来。</p>
<h1 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h1><p>对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ul>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ul>
<p><strong><em>目的：避免线程可能看到的final值被改变。</em></strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/19/Java高并发编程/" rel="next" title="Java高并发编程">
                <i class="fa fa-chevron-left"></i> Java高并发编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/29/Spring源码阅读/" rel="prev" title="Spring源码阅读">
                Spring源码阅读 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://picture.tjtulong.top/QQ%E5%9B%BE%E7%89%8720190515225418.jpg" alt="Tulong Xiao">
            
              <p class="site-author-name" itemprop="name">Tulong Xiao</p>
              <p class="site-description motion-element" itemprop="description">Almost Famous</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TJtulong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:TJtulong@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/2610493505/home" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/TJtulong" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-book"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.tongji.edu.cn/" title="同济大学" target="_blank">同济大学</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java内存模型"><span class="nav-number">1.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#主内存与工作内存"><span class="nav-number">1.1.</span> <span class="nav-text">主内存与工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存间交互操作"><span class="nav-number">1.2.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超线程"><span class="nav-number">1.3.</span> <span class="nav-text">超线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cache-line"><span class="nav-number">1.4.</span> <span class="nav-text">cache  line</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">1.5.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#happens-before"><span class="nav-number">1.6.</span> <span class="nav-text">happens-before</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sychronized实现原理"><span class="nav-number">2.</span> <span class="nav-text">sychronized实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#锁升级的过程"><span class="nav-number">2.1.</span> <span class="nav-text">锁升级的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-number">2.1.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-number">2.1.2.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁"><span class="nav-number">2.1.3.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cxq与EntryList"><span class="nav-number">2.1.4.</span> <span class="nav-text">cxq与EntryList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁、轻量级锁的状态转换"><span class="nav-number">2.1.5.</span> <span class="nav-text">偏向锁、轻量级锁的状态转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自旋锁"><span class="nav-number">2.2.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁消除"><span class="nav-number">2.3.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁粗化"><span class="nav-number">2.4.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sychronized的底层实现"><span class="nav-number">2.5.</span> <span class="nav-text">Sychronized的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized与Lock的对比"><span class="nav-number">2.6.</span> <span class="nav-text">Synchronized与Lock的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile关键字"><span class="nav-number">3.</span> <span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile的特性"><span class="nav-number">3.1.</span> <span class="nav-text">volatile的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可见性"><span class="nav-number">3.1.1.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不保证原子性"><span class="nav-number">3.1.2.</span> <span class="nav-text">不保证原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#禁止指令重排"><span class="nav-number">3.1.3.</span> <span class="nav-text">禁止指令重排</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile的内存语义"><span class="nav-number">3.2.</span> <span class="nav-text">volatile的内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile内存语义的实现"><span class="nav-number">3.3.</span> <span class="nav-text">volatile内存语义的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存屏障"><span class="nav-number">3.3.1.</span> <span class="nav-text">内存屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器重排序"><span class="nav-number">3.3.2.</span> <span class="nav-text">编译器重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理器重排序"><span class="nav-number">3.3.3.</span> <span class="nav-text">处理器重排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#底层原理"><span class="nav-number">3.3.4.</span> <span class="nav-text">底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DCL单例模式"><span class="nav-number">3.4.</span> <span class="nav-text">DCL单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和volatile的区别"><span class="nav-number">3.5.</span> <span class="nav-text">synchronized和volatile的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS"><span class="nav-number">4.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CompareAndSwap"><span class="nav-number">4.1.</span> <span class="nav-text">CompareAndSwap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS底层原理"><span class="nav-number">4.2.</span> <span class="nav-text">CAS底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS的缺点"><span class="nav-number">4.3.</span> <span class="nav-text">CAS的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ABA问题解决"><span class="nav-number">4.4.</span> <span class="nav-text">ABA问题解决</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#各种锁"><span class="nav-number">5.</span> <span class="nav-text">各种锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#公平锁与非公平锁"><span class="nav-number">5.1.</span> <span class="nav-text">公平锁与非公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重入锁"><span class="nav-number">5.2.</span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自旋锁-1"><span class="nav-number">5.3.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写锁"><span class="nav-number">5.4.</span> <span class="nav-text">读写锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal的原理"><span class="nav-number">6.</span> <span class="nav-text">ThreadLocal的原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final域的内存语义"><span class="nav-number">7.</span> <span class="nav-text">final域的内存语义</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tulong Xiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
