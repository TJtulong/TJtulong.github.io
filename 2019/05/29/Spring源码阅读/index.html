<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Spring源码,">










<meta name="description" content="IOC源码分析ClassPathXmlApplicationContext的构造的核心是refresh()【创建刷新】方法。">
<meta name="keywords" content="Spring源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码阅读">
<meta property="og:url" content="http://yoursite.com/2019/05/29/Spring源码阅读/index.html">
<meta property="og:site_name" content="椰子皮&#39;s Blog">
<meta property="og:description" content="IOC源码分析ClassPathXmlApplicationContext的构造的核心是refresh()【创建刷新】方法。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://picture.tjtulong.top/ApplicationContext%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://picture.tjtulong.top/%E7%BC%93%E5%AD%98%E9%9B%86%E5%90%88.JPG">
<meta property="og:updated_time" content="2019-06-03T06:40:08.360Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring源码阅读">
<meta name="twitter:description" content="IOC源码分析ClassPathXmlApplicationContext的构造的核心是refresh()【创建刷新】方法。">
<meta name="twitter:image" content="http://picture.tjtulong.top/ApplicationContext%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/29/Spring源码阅读/">





  <title>Spring源码阅读 | 椰子皮's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">椰子皮's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/Spring源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tulong Xiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://picture.tjtulong.top/QQ%E5%9B%BE%E7%89%8720190515225418.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="椰子皮's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring源码阅读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T14:25:35+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="IOC源码分析"><a href="#IOC源码分析" class="headerlink" title="IOC源码分析"></a>IOC源码分析</h1><p><img src="http://picture.tjtulong.top/ApplicationContext%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="enter description here"><br>ClassPathXmlApplicationContext的构造的核心是<strong>refresh()</strong>【创建刷新】方法。<br><a id="more"></a></p>
<h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh()"></a>refresh()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanFactory的创建及预准备工作"><a href="#BeanFactory的创建及预准备工作" class="headerlink" title="BeanFactory的创建及预准备工作"></a>BeanFactory的创建及预准备工作</h2><ol>
<li><strong>prepareRefresh();</strong> 刷新前的预处理<br> 1）initPropertySources()初始化一些属性设置；子类自定义个性化的属性设置方法；<br> 2）getEnvironment().validateRequiredProperties(); 检验属性的合法等<br> 3）<code>earlyApplicationEvents= new LinkedHashSet&lt;ApplicationEvent&gt;();</code>保存容器中的一些早期的事件；</li>
<li><strong>obtainFreshBeanFactory();</strong> 获取BeanFactory；<br> 1）refreshBeanFactory();刷新【创建】BeanFactory；<br> 创建了一个this.beanFactory = new DefaultListableBeanFactory();<br> 设置id；<br> 2）getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；<br> 3）将创建的BeanFactory【DefaultListableBeanFactory】返回；</li>
<li><strong>prepareBeanFactory(beanFactory);</strong> BeanFactory的预准备工作（BeanFactory进行一些设置）；<br> 1）设置BeanFactory的类加载器、支持表达式解析器…<br> 2）添加部分BeanPostProcessor【ApplicationContextAwareProcessor】<br> 3）设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；<br> 4）注册可以解析的自动装配；我们能直接在任何组件中自动注入：<br> BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext<br> 5）添加BeanPostProcessor【ApplicationListenerDetector】<br> 6）添加编译时的AspectJ；<br> 7）给BeanFactory中注册一些能用的组件:<br> environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】</li>
<li><strong>postProcessBeanFactory(beanFactory);</strong> BeanFactory准备工作完成后进行的后置处理工作；<br> 1）子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置</li>
</ol>
<h2 id="后处理组件"><a href="#后处理组件" class="headerlink" title="后处理组件"></a>后处理组件</h2><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanPostProcessor：bean后置处理器，bean创建对象初始化前后进行拦截工作的。</p>
<p>BeanFactoryPostProcessor：<strong>beanFactory的后置处理器</strong>，在BeanFactory标准初始化之后调用，所有的bean定义已经加载到beanFactory，但bean的实例还未创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"MyBeanFactoryPostProcessor...postProcessBeanFactory..."</span>);</span><br><span class="line">		<span class="keyword">int</span> count = beanFactory.getBeanDefinitionCount();</span><br><span class="line">		String[] names = beanFactory.getBeanDefinitionNames();</span><br><span class="line">		System.out.println(<span class="string">"当前BeanFactory中有"</span>+count+<span class="string">" 个Bean"</span>);</span><br><span class="line">		System.out.println(Arrays.asList(names));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BeanFactoryPostProcessor原理</strong>:</p>
<ol>
<li>ioc容器创建对象</li>
<li>invokeBeanFactoryPostProcessors(beanFactory);<br>直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法，（在初始化创建其他组件前面执行）。</li>
</ol>
<h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><p>BeanDefinitionRegistryPostProcessor接口是BeanFactoryPostProcessor接口的子类。</p>
<p>在所有bean定义信息将要被加载，bean实例还未创建的时机执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanDefinitionRegistryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"MyBeanDefinitionRegistryPostProcessor...bean的数量："</span>+beanFactory.getBeanDefinitionCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//BeanDefinitionRegistry Bean定义信息的保存中心，以后BeanFactory就是按照BeanDefinitionRegistry里面保存的每一个bean定义信息创建bean实例；</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessBeanDefinitionRegistry...bean的数量："</span>+registry.getBeanDefinitionCount());</span><br><span class="line">		<span class="comment">//RootBeanDefinition beanDefinition = new RootBeanDefinition(Blue.class);</span></span><br><span class="line">		AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(Blue.class).getBeanDefinition();</span><br><span class="line">		registry.registerBeanDefinition(<span class="string">"hello"</span>, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanDefinitionRegistryPostProcessor优先于BeanFactoryPostProcessor执行，可以利用BeanDefinitionRegistryPostProcessor给容器中再额外添加一些组件；</p>
<p><strong>原理：</strong></p>
<ol>
<li>ioc创建对象；</li>
<li>refresh()—&gt;invokeBeanFactoryPostProcessors(beanFactory);</li>
<li>从容器中获取到所有的<strong>BeanDefinitionRegistryPostProcessor组件</strong>：<br>1）依次触发所有的postProcessBeanDefinitionRegistry()方法；<br>2）再来触发postProcessBeanFactory()方法；</li>
<li>再来从容器中找到<strong>BeanFactoryPostProcessor组件</strong>，然后依次触发postProcessBeanFactory()方法。</li>
</ol>
<h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p>监听容器中发生的事件，进行事件驱动模型开发。</p>
<p><code>public interface ApplicationListener&lt;E extends ApplicationEvent&gt;</code>，监听 ApplicationEvent 及其下面的子事件；</p>
<p><strong>步骤：</strong></p>
<ol>
<li>写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）<br><strong>@EventListener;</strong><br>原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener；</li>
<li>把监听器加入到容器；</li>
<li>只要容器中有相关事件的发布，我们就能监听到这个事件；<br>ContextRefreshedEvent：容器刷新完成（所有bean都完全创建）会发布这个事件；<br>ContextClosedEvent：关闭容器会发布这个事件；</li>
<li>发布一个事件：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.publishEvent(<span class="keyword">new</span> ApplicationEvent(<span class="keyword">new</span> String(<span class="string">"我发布的时间"</span>)) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当容器中发布此事件以后，方法触发</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"收到事件："</span>+event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原理：</strong><br>上面程序依次输出：ContextRefreshedEvent、IOCTest_Ext$1[source=我发布的时间]、ContextClosedEvent；</p>
<ol>
<li>ContextRefreshedEvent事件：<br>容器创建对象：refresh()；<br>finishRefresh();容器刷新完成会<strong>发布ContextRefreshedEvent事件</strong></li>
<li>自己发布事件；</li>
<li>容器关闭会发布ContextClosedEvent；</li>
</ol>
<h4 id="事件发布流程"><a href="#事件发布流程" class="headerlink" title="事件发布流程"></a>事件发布流程</h4><p>publishEvent(new ContextRefreshedEvent(this));</p>
<ol>
<li>获取事件的多播器（派发器）：getApplicationEventMulticaster()</li>
<li>multicastEvent派发事件：</li>
<li><strong>获取到所有的ApplicationListener</strong>；<br>for (final ApplicationListener listener : getApplicationListeners(event, type)) {<br>1.如果有Executor，可以支持使用Executor进行异步派发；<br>Executor executor = getTaskExecutor();<br>2.否则，同步的方式直接执行listener方法；invokeListener(listener, event);<br>拿到listener回调onApplicationEvent方法；<br>}                </li>
</ol>
<h4 id="事件多播器（派发器）"><a href="#事件多播器（派发器）" class="headerlink" title="事件多播器（派发器）"></a>事件多播器（派发器）</h4><ol>
<li>容器创建对象：refresh();</li>
<li><strong>initApplicationEventMulticaster();</strong>初始化<strong>ApplicationEventMulticaster</strong>；<br>1）先去容器中找有没有id=“applicationEventMulticaster”的组件；<br>2）如果没有，可以this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);并且加入到容器中，我们就可以在其他组件要派发事件，自动注入这个applicationEventMulticaster；</li>
</ol>
<h4 id="容器中有哪些监听器"><a href="#容器中有哪些监听器" class="headerlink" title="容器中有哪些监听器"></a>容器中有哪些监听器</h4><ol>
<li>容器创建对象：refresh();</li>
<li><strong>registerListeners();</strong><br>从容器中拿到所有的监听器，把他们注册到applicationEventMulticaster中:<br><code>String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</code><br>将listener注册到多播器ApplicationEventMulticaster中:<br><code>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</code></li>
</ol>
<h4 id="SmartInitializingSingleton"><a href="#SmartInitializingSingleton" class="headerlink" title="SmartInitializingSingleton"></a>SmartInitializingSingleton</h4><p>原理：—&gt;afterSingletonsInstantiated();</p>
<ol>
<li>ioc容器创建对象并refresh()；</li>
<li><strong>finishBeanFactoryInitialization(beanFactory);</strong> 初始化剩下的单实例bean；<br>1）先创建所有的单实例bean；getBean();<br>2）获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的；如果是就调用<strong>afterSingletonsInstantiated()</strong>;</li>
</ol>
<h2 id="注册后处理组件"><a href="#注册后处理组件" class="headerlink" title="注册后处理组件"></a>注册后处理组件</h2><p><strong>5.invokeBeanFactoryPostProcessors(beanFactory);</strong> 执行BeanFactoryPostProcessor的方法；</p>
<p>BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；共有两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</p>
<p>执行BeanFactoryPostProcessor的方法：<strong>先执行BeanDefinitionRegistryPostProcessor</strong></p>
<ol>
<li>获取所有的BeanDefinitionRegistryPostProcessor；</li>
<li>首先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、postProcessor.postProcessBeanDefinitionRegistry(registry)</li>
<li>再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；<br>postProcessor.postProcessBeanDefinitionRegistry(registry)</li>
<li>最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；<br>postProcessor.postProcessBeanDefinitionRegistry(registry)        </li>
</ol>
<p><strong>再执行BeanFactoryPostProcessor的方法</strong></p>
<ol>
<li>获取所有的BeanFactoryPostProcessor</li>
<li>首先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、<br>postProcessor.postProcessBeanFactory()</li>
<li>再执行实现了Ordered顺序接口的BeanFactoryPostProcessor；<br>postProcessor.postProcessBeanFactory()</li>
<li>最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；<br>postProcessor.postProcessBeanFactory()</li>
</ol>
<p><strong>6.registerBeanPostProcessors(beanFactory);</strong> 注册BeanPostProcessor（Bean的后置处理器）【 intercept bean creation】<br><em>注意：只注册不执行！</em></p>
<p>不同接口类型的BeanPostProcessor，在Bean创建前后的执行时机是不一样的：</p>
<ul>
<li>BeanPostProcessor、</li>
<li>DestructionAwareBeanPostProcessor、</li>
<li>InstantiationAwareBeanPostProcessor、</li>
<li>SmartInstantiationAwareBeanPostProcessor、</li>
<li>MergedBeanDefinitionPostProcessor【internalPostProcessors】、</li>
</ul>
<p>步骤：</p>
<ol>
<li>获取所有的<strong>BeanPostProcessor</strong>;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级</li>
<li>先注册PriorityOrdered优先级接口的BeanPostProcessor；把每一个BeanPostProcessor添加到BeanFactory中：beanFactory.addBeanPostProcessor(postProcessor);</li>
<li>再注册Ordered接口的</li>
<li>最后注册没有实现任何优先级接口的</li>
<li>最终注册MergedBeanDefinitionPostProcessor；</li>
<li>注册一个<strong>ApplicationListenerDetector</strong>来在Bean创建完成后检查是否是ApplicationListener，如果是：<br>applicationContext.addApplicationListener((ApplicationListener) bean);</li>
</ol>
<p><strong>7.initMessageSource();</strong> 初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</p>
<ol>
<li>获取BeanFactory</li>
<li>看容器中是否有id为messageSource的，类型是MessageSource的组件，如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；<br>MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；</li>
<li>把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);	</span><br><span class="line">MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale);</span><br></pre></td></tr></table></figure>
<p><strong>8.initApplicationEventMulticaster();</strong> 初始化事件派发器；</p>
<ol>
<li>获取BeanFactory</li>
<li>从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；</li>
<li>如果上一步没有配置；创建一个SimpleApplicationEventMulticaster</li>
<li>将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入。</li>
</ol>
<p><strong>9.onRefresh();</strong> 留给子容器（子类）<br>子类重写这个方法，在容器刷新的时候可以自定义逻辑。</p>
<p><strong>10.registerListeners();</strong> 给容器中将所有项目里面的ApplicationListener注册进来；</p>
<ol>
<li>从容器中拿到所有的ApplicationListener</li>
<li>将每个监听器添加到事件派发器中；<br>getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</li>
<li>派发之前步骤产生的事件；</li>
</ol>
<h2 id="创建Bean准备"><a href="#创建Bean准备" class="headerlink" title="创建Bean准备"></a>创建Bean准备</h2><p><strong>11. finishBeanFactoryInitialization(beanFactory);</strong> 初始化所有剩下的单实例bean；<br>一. beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean</p>
<ol>
<li>获取容器中的所有Bean，依次进行初始化和创建对象；</li>
<li>获取Bean的定义信息；RootBeanDefinition</li>
<li>Bean不是抽象的，是单实例的，不是懒加载；<br>　(1) 判断是否是FactoryBean；是否是实现FactoryBean接口的Bean；<br>　(2) 不是工厂Bean，利用getBean(beanName)创建对象<br>　　　0、getBean(beanName)； ioc.getBean();<br>　　　1、doGetBean(name, null, null, false);<br>　　　2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来）从<code>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);</code>获取的<br>　　　3、缓存中获取不到，开始Bean的创建对象流程；<br>　　　4、标记当前bean已经被创建<br>　　　5、获取Bean的定义信息(BeanDefination)；<br>　　　6、<strong>获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；</strong><br>　　　7、启动单实例Bean的创建流程；<br>　　　　　ａ.createBean(beanName, mbd, args);<br>　　　　　ｂ. Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象；<br>　　　　　【InstantiationAwareBeanPostProcessor】：提前执行；<br>　　　　　先触发：postProcessBeforeInstantiation()；<br>　　　　　如果有返回值：触发postProcessAfterInitialization()；<br>  　　　　c. 如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象，调用下面。</li>
</ol>
<h2 id="Bean创建完成"><a href="#Bean创建完成" class="headerlink" title="Bean创建完成"></a>Bean创建完成</h2><p>Object beanInstance = doCreateBean(beanName, mbdToUse, args); 创建Bean</p>
<ol>
<li>【创建Bean实例】；<br>createBeanInstance(beanName, mbd, args);<br>利用工厂方法或者对象的构造器创建出Bean实例；</li>
<li>applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</li>
<li>【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);<br>赋值之前：<br>（1）拿到InstantiationAwareBeanPostProcessor后置处理器:<br>postProcessAfterInstantiation()；<br>（2）拿到InstantiationAwareBeanPostProcessor后置处理器；<br>postProcessPropertyValues()；<br>（3）应用Bean属性的值，为属性利用setter方法等进行赋值；<br><strong>applyPropertyValues(beanName, mbd, bw, pvs);</strong></li>
<li>[Bean初始化]initializeBean(beanName, exposedObject, mbd);<br>（1）[执行Aware接口方法]invokeAwareMethods(beanName, bean);执行xxxAware接口的方法BeanNameAware\BeanClassLoaderAware\BeanFactoryAware<br>（2）[执行后置处理器初始化之前]<br>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br><strong>BeanPostProcessor.postProcessBeforeInitialization（）;</strong><br>（3）[执行初始化方法]<strong>invokeInitMethods(beanName, wrappedBean, mbd);</strong><br>是否是InitializingBean接口的实现；执行接口规定的初始化；<br>是否自定义初始化方法；<br>（4）[执行后置处理器初始化之后]applyBeanPostProcessorsAfterInitialization<br><strong>BeanPostProcessor.postProcessAfterInitialization()；</strong><br>（5）注册Bean的销毁方法；</li>
</ol>
<p><strong>将创建的Bean添加到缓存中singletonObjects（ConcurrentHashMap)，ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息…；</strong><br><img src="http://picture.tjtulong.top/%E7%BC%93%E5%AD%98%E9%9B%86%E5%90%88.JPG" alt="enter description here"></p>
<p>所有Bean都利用getBean创建完成以后，检查所有的Bean是否是SmartInitializingSingleton接口的；如果是，就执行afterSingletonsInstantiated()；</p>
<p><strong>12.finishRefresh();完成BeanFactory的初始化创建工作；IOC容器就创建完成；</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息；</strong></li>
</ol>
<ul>
<li>xml注册bean；</li>
<li>注解注册Bean；@Service、@Component、@Bean、xxx</li>
</ul>
<ol start="2">
<li><strong>Spring容器会合适的时机创建这些Bean；</strong></li>
</ol>
<ul>
<li>用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；</li>
<li>一创建剩下所有的bean的时候；finishBeanFactoryInitialization()；</li>
</ul>
<ol start="3">
<li><strong>后置处理器；BeanPostProcessor</strong><br>每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；</li>
</ol>
<ul>
<li>AutowiredAnnotationBeanPostProcessor:处理自动注入</li>
<li>AnnotationAwareAspectJAutoProxyCreator:来做AOP功能</li>
<li>AsyncAnnotationBeanPostProcessor</li>
</ul>
<ol start="4">
<li><strong>事件驱动模型；</strong><br>ApplicationListener；事件监听<br>ApplicationEventMulticaster；事件派发</li>
</ol>
<h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><p>bean的生命周期：bean从创建到初始化到销毁的过程，由容器进行管理</p>
<p>我们可以自定义<strong>初始化和销毁方法</strong>；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"car constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"car ... init..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"car ... detory..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>构造（对象创建）：</p>
<ul>
<li>单实例：在容器启动的时候创建对象</li>
<li>多实例：在每次获取的时候创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.atguigu.bean"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//@Scope("prototype")</span></span><br><span class="line">	<span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>,destroyMethod=<span class="string">"detory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> BeanPostProcessor.postProcessBeforeInitialization<br> 初始化：对象创建完成，并赋值好，调用初始化方法。。。</p>
<p>BeanPostProcessor.postProcessAfterInitialization<br>销毁：</p>
<ul>
<li>单实例：容器关闭的时候销毁</li>
<li>多实例：容器不会管理这个bean；容器不会调用销毁方法；</li>
</ul>
<h2 id="InitializingBean与DisposableBean"><a href="#InitializingBean与DisposableBean" class="headerlink" title="InitializingBean与DisposableBean"></a>InitializingBean与DisposableBean</h2><p>通过让Bean实现InitializingBean定义初始化逻辑，DisposableBean定义销毁逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"cat...destroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"cat...afterPropertiesSet..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可以使用JSR250；"><a href="#可以使用JSR250；" class="headerlink" title="可以使用JSR250；"></a>可以使用JSR250；</h2><p>@PostConstruct：在bean创建完成并且属性赋值完成，来执行初始化方法<br>@PreDestroy：在容器销毁bean之前通知我们进行清理工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dog constructor..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对象创建并赋值之后调用</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Dog....@PostConstruct..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//容器移除对象之前</span></span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Dog....@PreDestroy..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a>后置处理器</h2><p>BeanPostProcessor【interface】：bean的后置处理器<br>在bean初始化前后进行一些处理工作：</p>
<ul>
<li>postProcessBeforeInitialization:在初始化之前工作</li>
<li>postProcessAfterInitialization:在初始化之后工作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器：初始化前后进行处理工作</span></span><br><span class="line"><span class="comment"> * 将后置处理器加入到容器中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessBeforeInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"postProcessAfterInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BeanPostProcessor原理：</strong><br>populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值<br>initializeBean<br>{<br>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化<br>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br> }</p>
<p>遍历得到容器中所有的BeanPostProcessor，挨个执行beforeInitialization，一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring源码/" rel="tag"># Spring源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/22/Java并发机制的底层实现/" rel="next" title="Java并发机制的底层实现">
                <i class="fa fa-chevron-left"></i> Java并发机制的底层实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/30/SpringMVC基本操作/" rel="prev" title="SpringMVC基本操作">
                SpringMVC基本操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://picture.tjtulong.top/QQ%E5%9B%BE%E7%89%8720190515225418.jpg" alt="Tulong Xiao">
            
              <p class="site-author-name" itemprop="name">Tulong Xiao</p>
              <p class="site-description motion-element" itemprop="description">Almost Famous</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TJtulong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:TJtulong@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/2610493505/home" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/TJtulong" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-book"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.tongji.edu.cn/" title="同济大学" target="_blank">同济大学</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC源码分析"><span class="nav-number">1.</span> <span class="nav-text">IOC源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#refresh"><span class="nav-number">1.1.</span> <span class="nav-text">refresh()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanFactory的创建及预准备工作"><span class="nav-number">1.2.</span> <span class="nav-text">BeanFactory的创建及预准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后处理组件"><span class="nav-number">1.3.</span> <span class="nav-text">后处理组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactoryPostProcessor"><span class="nav-number">1.3.1.</span> <span class="nav-text">BeanFactoryPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanDefinitionRegistryPostProcessor"><span class="nav-number">1.3.2.</span> <span class="nav-text">BeanDefinitionRegistryPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationListener"><span class="nav-number">1.3.3.</span> <span class="nav-text">ApplicationListener</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事件发布流程"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">事件发布流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件多播器（派发器）"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">事件多播器（派发器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器中有哪些监听器"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">容器中有哪些监听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SmartInitializingSingleton"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">SmartInitializingSingleton</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册后处理组件"><span class="nav-number">1.4.</span> <span class="nav-text">注册后处理组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建Bean准备"><span class="nav-number">1.5.</span> <span class="nav-text">创建Bean准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean创建完成"><span class="nav-number">1.6.</span> <span class="nav-text">Bean创建完成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bean的生命周期"><span class="nav-number">2.</span> <span class="nav-text">bean的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean"><span class="nav-number">2.1.</span> <span class="nav-text">@Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InitializingBean与DisposableBean"><span class="nav-number">2.2.</span> <span class="nav-text">InitializingBean与DisposableBean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以使用JSR250；"><span class="nav-number">2.3.</span> <span class="nav-text">可以使用JSR250；</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后置处理器"><span class="nav-number">2.4.</span> <span class="nav-text">后置处理器</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tulong Xiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
