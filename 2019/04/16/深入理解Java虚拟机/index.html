<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-circle.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JVM,">










<meta name="description" content="走近JavaJDK、JRE与JVM之间的关系：JDK全程为Java SE Development Kit（Java开发工具），提供了编译和运行Java程序所需的各种资源和工具，包括：JRE+java开发工具。JRE全称为Java runtime environment（Java运行环境），包括：虚拟机+java的核心类库。JVM是运行Java程序的核心虚拟机。  内存溢出的问题及解决1234567">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机">
<meta property="og:url" content="http://yoursite.com/2019/04/16/深入理解Java虚拟机/index.html">
<meta property="og:site_name" content="椰子皮&#39;s Blog">
<meta property="og:description" content="走近JavaJDK、JRE与JVM之间的关系：JDK全程为Java SE Development Kit（Java开发工具），提供了编译和运行Java程序所需的各种资源和工具，包括：JRE+java开发工具。JRE全称为Java runtime environment（Java运行环境），包括：虚拟机+java的核心类库。JVM是运行Java程序的核心虚拟机。  内存溢出的问题及解决1234567">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/JDK.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%86%85%E5%AD%98.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/Memory.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%A0%86%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.png">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/MarkWord.jpg">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%8F%A5%E6%9F%84%E6%B1%A0.png">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.png">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/Eden.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/PerNew.jpeg">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/jps.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/jpsl.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/Jstat.JPG">
<meta property="og:image" content="http://ppznxle2c.bkt.clouddn.com/Jinfo.JPG">
<meta property="og:updated_time" content="2019-04-19T09:51:53.268Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Java虚拟机">
<meta name="twitter:description" content="走近JavaJDK、JRE与JVM之间的关系：JDK全程为Java SE Development Kit（Java开发工具），提供了编译和运行Java程序所需的各种资源和工具，包括：JRE+java开发工具。JRE全称为Java runtime environment（Java运行环境），包括：虚拟机+java的核心类库。JVM是运行Java程序的核心虚拟机。  内存溢出的问题及解决1234567">
<meta name="twitter:image" content="http://ppznxle2c.bkt.clouddn.com/JDK.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/16/深入理解Java虚拟机/">





  <title>深入理解Java虚拟机 | 椰子皮's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">椰子皮's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/16/深入理解Java虚拟机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tulong Xiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://ppznxle2c.bkt.clouddn.com/IMG_1547.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="椰子皮's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Java虚拟机</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-16T17:28:18+08:00">
                2019-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java基础/" itemprop="url" rel="index">
                    <span itemprop="name">java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="走近Java"><a href="#走近Java" class="headerlink" title="走近Java"></a>走近Java</h1><h2 id="JDK、JRE与JVM之间的关系："><a href="#JDK、JRE与JVM之间的关系：" class="headerlink" title="JDK、JRE与JVM之间的关系："></a>JDK、JRE与JVM之间的关系：</h2><p><strong>JDK</strong>全程为Java SE Development Kit（Java开发工具），提供了编译和运行Java程序所需的各种资源和工具，包括：JRE+java开发工具。<br><strong>JRE</strong>全称为Java runtime environment（Java运行环境），包括：虚拟机+java的核心类库。<br><strong>JVM</strong>是运行Java程序的核心虚拟机。</p>
<p><img src="http://ppznxle2c.bkt.clouddn.com/JDK.JPG" alt="enter description here"></p>
<h2 id="内存溢出的问题及解决"><a href="#内存溢出的问题及解决" class="headerlink" title="内存溢出的问题及解决"></a>内存溢出的问题及解决</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Demo&gt; demoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            demoList.add(<span class="keyword">new</span> Demo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上面代码所示，不断向堆内存中加入对象，会造成异常：<em>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</em>，运行过程中计算机内存不断上升直到报错。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%86%85%E5%AD%98.JPG" alt="enter description here"></p>
<p>可以通过添加参数-XX:+HeapDumpOnOutOfMemoryError -Xms20m -Xmx20m 来输出堆存储快照，在项目目录下出现名为<strong>java_pid24672.hprof</strong>的文件。如果想解析该文件，需要下载Eclipse提供的解析器MemoryAnalyzer，下载地址为：<a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/mat/downloads.php</a> 通过该软件打开java_pid24672.hprof文件可以看到内存的实际应用情况，判断内存溢出原因。<br><img src="http://ppznxle2c.bkt.clouddn.com/Memory.JPG" alt="enter description here"></p>
<h2 id="jvm可视化监控工具"><a href="#jvm可视化监控工具" class="headerlink" title="jvm可视化监控工具"></a>jvm可视化监控工具</h2><p>jdk自带可视化监控工具，在目录C:\Program Files\Java\jdk1.8.0_171\bin下，直接在命令行输入jconsole即可运行，源代码在tools.jar包中。</p>
<p>运行如下代码，不断向集合中加入元素，堆内存不断增大：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JConsoleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"start..."</span>);</span><br><span class="line">        fill(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;JConsoleTest&gt; jlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            jlist.add(<span class="keyword">new</span> JConsoleTest());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ppznxle2c.bkt.clouddn.com/%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.JPG" alt="enter description here"></p>
<p>同时可以看出Eden区呈折线变化，这是由于垃圾回收机制的回收作用。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.JPG" alt="enter description here"></p>
<h2 id="Java的发展"><a href="#Java的发展" class="headerlink" title="Java的发展"></a>Java的发展</h2><p>Java之父：<strong>詹姆斯·高斯林</strong></p>
<p>最早语言为Oak，用于嵌入式系统，没有成功；<br>1995年互联网发展，改名为Java，开始火爆，提出Write once run anywhere的原则；<br>1996年1月 发布JDK1.0，jvm为Sun Classic VM；<br>1996年5月 首届JavaOne大会；<br>1997年2月 JDK1.1（内部类、反射、jdbc、javabean、rmi）；<br>1998年 JDK1.2 发布J2Se J2EE J2ME swing jit Hotspot VM；<br>2000年5月 JDK1.3 Timer Java2d；<br>2002年2月 JDK1.4 Struts Hibernate Spring 正则表达式 NIO 日志 Xml解析器；<br>2004年9月 JDK1.5(tiger) 自动装箱拆箱 泛型 注解 枚举 增强for 可变参数 Spring2.X；<br>2006年 JDK6 JavaSe JavaEE JavaME 提供脚本语言支持 支持http服务器api；<br>2009年 Java7 Jigsaw模块化 Orical74亿收购Sun；<br>2014年 Java8 Lambda表达式 函数式接口 方法引用 默认方法 Stream；<br>2017年 Java9 模块化</p>
<h2 id="java技术体系"><a href="#java技术体系" class="headerlink" title="java技术体系"></a>java技术体系</h2><ul>
<li>Java程序设计语言</li>
<li>各硬件平台上的Java虚拟机</li>
<li>Class文件格式，可以自己设计语言，自己编写编译器，生成相同的class文件即可</li>
<li>Java API</li>
<li>第三方的Java类库</li>
</ul>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>关于Jit编译器和解释器和关系，见博客：<a href="https://www.cnblogs.com/insistence/p/5901457.html" target="_blank" rel="noopener">https://www.cnblogs.com/insistence/p/5901457.html</a></p>
<h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><p>已经淘汰，是世界上第一款商用虚拟机，只能使用纯解释器（没有JITJust in time编译器）的方法来执行Java代码。</p>
<h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><p>Exact Memory Management 准确式内存管理；<br>编译器和解释器混合工作以及两级即时编译器。</p>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><p>热点代码技术，使用最多的虚拟机产品，并非由Sun公司开发。官方JDK均采用HotSpot VM。</p>
<h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p>kilobyte 简单、轻量、高度可移植，在手机平台运行，运行速度慢。</p>
<h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><p>BEA公司开发，是世界上最快的Java虚拟机，专注于服务端应用，全部靠编译器执行。</p>
<h3 id="J9"><a href="#J9" class="headerlink" title="J9"></a>J9</h3><p>IBM开发 原名：IBM Techn0ology for Java Virtual Machine IT4j</p>
<h3 id="Davik"><a href="#Davik" class="headerlink" title="Davik"></a>Davik</h3><p>不是java虚拟机，寄存器架构而不是栈结构，执行dex（dalvik Executable）文件。</p>
<h3 id="Microsoft-JVM"><a href="#Microsoft-JVM" class="headerlink" title="Microsoft JVM"></a>Microsoft JVM</h3><p>只能运行在windows下面。</p>
<h3 id="Azul-VM-Liquid-VM"><a href="#Azul-VM-Liquid-VM" class="headerlink" title="Azul VM Liquid VM"></a>Azul VM Liquid VM</h3><p><strong>高性能</strong>的java虚拟机，在HotSpot基础上改进，专用的虚拟机。</p>
<h3 id="Taobao-VM"><a href="#Taobao-VM" class="headerlink" title="Taobao VM"></a>Taobao VM</h3><p>淘宝公司开发</p>
<h1 id="Java虚拟机的内存管理"><a href="#Java虚拟机的内存管理" class="headerlink" title="Java虚拟机的内存管理"></a>Java虚拟机的内存管理</h1><p>分为线程共享区和线程独占区<br><img src="http://ppznxle2c.bkt.clouddn.com/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98.png" alt="enter description here"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器(处于线程独)占区是一个非常小的内存空间，它可以看成是当前线程所执行的<strong>字节码的行号指示器</strong>。此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟字节码指令的地址。如果正在执行的是native方法，那么这个计数器的值为undefined。<br><em>注：java中没有goto，为保留字</em></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的动态内存模型。<br><strong>栈帧：</strong> 每个方法执行都要创建一个栈帧，方法执行完毕，栈帧销毁。用于存储局部变量表，操作数栈，动态链接，方法出口等。<br><strong>局部变量表</strong>：存放编译期可知的各种基本数据类型，引用类型，局部变量表的大小在编译期便已经可以确定，在运行时期不会发生改变。<br><strong>栈的大小</strong>：如果栈满了，StackOverFlowError，递归调用很常见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start......"</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错Exception in thread "main" java.lang.StackOverflowError</span></span><br></pre></td></tr></table></figure>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈为虚拟机执行native方法服务</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>java虚拟机最大的内存区域，存放对象实例，也是垃圾收集器管理的主要区域，分为新生代（由Eden 与Survivor Space 组成）和老生代，可能会抛出OutOfMemoryError异常。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%A0%86%E5%86%85%E5%AD%98.png" alt="enter description here"></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存储虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态常量，即时编译后的代码等数据，也可能会抛出OutOfMemoryError异常。<br><strong>方法区与永久代</strong>实际并不等价，对于HotSpot中才有永久代的概念。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>每一个运行时常量池都在java虚拟机的<strong>方法区</strong>中分配。<br>例如在Java中字符串的创建会在常量池（方法区中StringTable：HashSet）中进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Changliang</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1与s2是相等的，为字节码常亮</span></span><br><span class="line">        String s1 = <span class="string">"abc"</span>;</span><br><span class="line">        String s2 = <span class="string">"abc"</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// s3创建在堆内存中</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// intern方法可以将对象变为运行时常量</span></span><br><span class="line">        <span class="comment">// intern是一个native方法</span></span><br><span class="line">        System.out.println(s1 == s3.intern()); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>直接内存</strong>：jdk1.4中增加了NIO，可以分配堆外内存（系统内存替代用户内存），提高了性能。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>一个对象创建的过程为：<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.png" alt="enter description here"></p>
<h3 id="如何在堆中给对象分配内存"><a href="#如何在堆中给对象分配内存" class="headerlink" title="如何在堆中给对象分配内存"></a>如何在堆中给对象分配内存</h3><p>两种方式：<strong>指针碰撞和空闲列表</strong>。我们具体使用的哪一种，就要看我们虚拟机中使用的是什么垃圾回收机制了，如果有压缩整理，可以使用指针碰撞的分配方式。<br><strong>指针碰撞</strong>：假设Java堆中内存是绝对<strong>规整</strong>的，所有用过的内存度放一边，空闲的内存放另一边，中间放着一个指针作为分界点的指示器，所分配内存就仅仅是把哪个指针向空闲空间那边挪动一段与对象大小相等的举例，这种分配方案就叫指针碰撞<br><strong>空闲列表</strong>：有一个列表，其中记录中哪些内存块有用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，然后更新列表中的记录，这就叫做空闲列表。</p>
<h3 id="线程安全性问题"><a href="#线程安全性问题" class="headerlink" title="线程安全性问题"></a>线程安全性问题</h3><p>在两个线程同时创建对象时，可能会造成空间分配的冲突，解决方案有：线程同步（但执行效率过低）或给每一个线程单独分配一个堆区域TLAB Thread Local Allocation Buffer（<strong>本地线程分配缓冲</strong>）。</p>
<h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p><strong>Header</strong>（对象头）</p>
<ul>
<li>自身运行时数据（32位~64位 MarkWord）：哈希值、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳<br><img src="http://ppznxle2c.bkt.clouddn.com/MarkWord.jpg" alt="enter description here"></li>
<li>类型指针（什么类的实例）</li>
</ul>
<p><strong>InstanceData</strong>：数据实例，即对象的有效信息，相同宽度（如long和double）的字段被分配在一起，父类属性在子类属性之前。<br><strong>Padding</strong>：占位符填充内存</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>对象的访问定位有两种方式：<strong>句柄访问和直接指针访问</strong><br><strong>句柄访问</strong>：Java堆中会划分出一块内存来作为句柄池，引用变量中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。一个句柄又包含了两个地址，一个对象实例数据，一个是对象类型数据(这个在方法区中，因为类字节码文件就放在方法区中)。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%8F%A5%E6%9F%84%E6%B1%A0.png" alt="enter description here"></p>
<p><strong>直接指针访问</strong>：引用变量中存储的就直接是对象地址了，在堆中不会分句柄池，直接指向了对象的地址，对象中包含了对象类型数据的地址。<strong>HotSpot采用直接定位</strong></p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>对于一般Java程序员开发的过程中，不需要考虑垃圾回收。</p>
<ul>
<li>如何判定对象为垃圾对象；<ol>
<li>引用计数法</li>
<li>可达性分析法</li>
</ol>
</li>
<li>如何回收垃圾对象；<ol>
<li>回收策略（标记清除、复制、标记整理、分带收集算法）</li>
<li>常见的垃圾回收器（Serial、Parnew、Cms、G1）</li>
</ol>
</li>
<li>何时回收垃圾对象。</li>
</ul>
<h2 id="判定垃圾对象"><a href="#判定垃圾对象" class="headerlink" title="判定垃圾对象"></a>判定垃圾对象</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就加1，当引用失效的时候（变量记为null），计数器的值就减1。但<strong>Java虚拟机中没有使用这种算法</strong>，这是由于如果堆内的对象之间相互引用，就始终不会发生计数器-1，那么就不会回收。</p>
<p>测试：两个对象相互引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 占据20M内存</span></span><br><span class="line">        <span class="keyword">byte</span>[] m = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span> *<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Count c1 = <span class="keyword">new</span> Count();</span><br><span class="line">        Count c2 = <span class="keyword">new</span> Count();</span><br><span class="line">        </span><br><span class="line">        c1.instance = c2;</span><br><span class="line">        c2.instance = c1;</span><br><span class="line">        <span class="comment">// 断掉引用</span></span><br><span class="line">        c1 = <span class="keyword">null</span>;</span><br><span class="line">        c2 = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印垃圾回收简易信息的参数：-verbose:gc<br>打印详细：-verbose:gc -XX:+PrintGCDetails<br>输出：<code>[GC (System.gc()) [PSYoungGen: 22476K-&gt;680K(38400K)] 42956K-&gt;21168K(125952K), 0.0008355 secs]</code>可以看出对象被回收，因此Java不使用引用计数算法。</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>此算法的核心思想：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots没有任何的引用链相连时(从GC Roots）到这个对象不可达)时，证明此对象不可用。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.png" alt="enter description here"><br>可作为GC Roots的对象：</p>
<ol>
<li>虚拟机栈</li>
<li>方法区的类属性所引用的对象</li>
<li>方法区中常量所引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ol>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>先标记出要回收的对象(一般使用可达性分析算法)，再去清除，但会有效率问题和空间问题:标记的空间被清除后，会造成我的内存中出现越来越多的<strong>不连续空间</strong>，当要分配一个大对象的时候，在进行寻址的要花费很多时间，可能会再一次触发垃圾回收。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><strong>堆</strong>：</p>
<ul>
<li>新生代<br>　　Eden 伊甸园<br>　　Survivor 存活期<br>　　Tenured Gen 老年区 　</li>
<li>老年代</li>
</ul>
<p><strong>复制算法</strong>是将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，浪费较大。复制算法的执行过程如下图所示：<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.JPG" alt="enter description here"><br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。<br><img src="http://ppznxle2c.bkt.clouddn.com/Eden.JPG" alt="enter description here"></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>对于老年代，回收的垃圾较少时，如果采用复制算法，则效率较低。标记整理算法的标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都<strong>向一端移动</strong>，并更新引用其对象的指针。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="enter description here"><br>很显然，整理这一下需要时间，所以与标记清除算法相比，这一步花费了不少时间，但从长远来看，这一步还是很有必要的。</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>针对不同的年代进行不同算法的垃圾回收，<strong>针对新生代选择复制算法，对老年代选择标记整理算法</strong>。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>Java的应用很广，内存区域也很多，可以使用不同的垃圾收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>单线程垃圾收集器、最基本、发展最悠久。它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束。偶尔用在桌面应用中。<br><img src="http://ppznxle2c.bkt.clouddn.com/%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.JPG" alt="enter description here"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>可多线程收集垃圾，收集新生代，使用收集算法<br><img src="http://ppznxle2c.bkt.clouddn.com/PerNew.jpeg" alt="enter description here"></p>
<h3 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h3><p>多线程收集垃圾，收集新生代，使用收集算法。Parallel收集器更关注系统的吞吐量，可以通过参数来打开自适应调节策略。</p>
<p><em>吞吐量：CPU用于运行用户代码的时间与CPU消耗的总时间的比值。</em><br><em>吞吐量 = （执行用户代码时间）/（执行用户代码时间+垃圾回收占用时间）</em></p>
<p>-XX:MaxGCPauseMillis 垃圾收集器最大停顿的时间，但最大停顿时间过短必然会导致新生代的内存大小变小，垃圾回收频率变高，效率可能降低。<br>-XX:CGTIMERatio 吞吐量大小（0-100），默认为99。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>Concurrent Mark Sweep，采用标记-清除算法，用于老年代，常与ParNew协同工作。优点在于并发收集与低停顿。<br><em>注：并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情</em></p>
<p>工作过程<br><img src="http://ppznxle2c.bkt.clouddn.com/CMS%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="enter description here"></p>
<ul>
<li><strong>初始标记</strong><br>标记老年代中所有的GC Roots对象和年轻代中活着的对象引用到的老年代的对象，时间短；</li>
<li><strong>并发标记</strong><br>从“初始标记”阶段标记的对象开始找出所有存活的对象；</li>
<li><strong>重新标记</strong><br>用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象，时间短；</li>
<li><strong>并发清理</strong><br>清除那些没有标记的对象并且回收空间。</li>
</ul>
<p>缺点：占用大量的cpu资源、无法处理浮点垃圾、出现Concurrent MarkFailure、空间碎片。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一，早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。</p>
<p>优势：并行（多核CPU）与并发；<br>　　　分代收集(新生代和老年代区分不明显)；<br>　　　空间整合；<br>　　　限制收集范围，可预测的停顿。<br>步骤：初始标记、并发标记、最终标记和筛选回收。<br><img src="http://ppznxle2c.bkt.clouddn.com/G1%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="enter description here"></p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p> <strong>原则：</strong></p>
<pre><code> 1. 优先分配到Eden
2. 大对象直接分配到老年代
3. 长期存活的对象分配到老年代
4. 空间分配担保
5. 动态对象的年龄判断
</code></pre><h2 id="Eden区域"><a href="#Eden区域" class="headerlink" title="Eden区域"></a>Eden区域</h2><p>-verbose:gc -XX:+PrintGCDetails 表示输出虚拟机中GC的详细情况。<br>默认使用Parallel收集器（服务器），Serial收集器（客户端），服务器和客户端可以通过java -version查看。也可以通过-XX:+UseSerialGC设置收集器。<br><code>-Xms20M -Xmx20M -Xmn10M</code>设置内存大小大小为20M，新生代大小为10M。<br><code>-XX:SurvivorRatio=8</code>设置eden 与survuvor 的比值大小 8:1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eden</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// -verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] b4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//第一次Minor回收</span></span><br><span class="line">        </span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GC日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 7291K-&gt;557K(9216K), 0.0051010 secs] 7291K-&gt;6701K(19456K), 0.0069568 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [Tenured: 6144K-&gt;6144K(10240K), 0.0017958 secs] 10957K-&gt;10793K(19456K), [Metaspace: 2699K-&gt;2699K(1056768K)], 0.0020720 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4813K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  58% used [0x00000000fec00000, 0x00000000ff0b3708, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2705K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 297K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure></p>
<p>JVM优先把对象放入Eden区，当Eden区放不下了后（2 * 3 = 6M），通过分配担保机制放入老年代6M（Minor GC），再把最后一个4M放入新生代。    </p>
<h2 id="大对象直接分配到老年代"><a href="#大对象直接分配到老年代" class="headerlink" title="大对象直接分配到老年代"></a>大对象直接分配到老年代</h2><p>我们认为大对象不是朝生夕死的，如果放在新生代，则需要不断移动，性能较差。<br><code>-XX:PretenureSizeThreshold=6M</code> 设置大文件大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Old</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7M大于设置的大文件的大小（6M），直接放入老年代。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tenured generation   total <span class="number">10240</span>K, used <span class="number">7168</span>K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space <span class="number">10240</span>K,  <span class="number">70</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00010</span>, <span class="number">0x00000000ffd00200</span>, <span class="number">0x0000000100000000</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="长期存活的对象分配到老年代"><a href="#长期存活的对象分配到老年代" class="headerlink" title="长期存活的对象分配到老年代"></a>长期存活的对象分配到老年代</h2><p><code>-XX:MaxTenuringThreshold</code>最大年龄，默认为15；<br>Age 1 + 1 + 1 使用年龄计数器。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p><code>-XX:+HandlePromotionFailure</code> 开启<br><code>-XX:-HandlePromotionFailure</code> 禁用<br>取之前每一次回收晋升到老年代对象容量的平均值大小作为经验值，与老年代的剩余空间进行比较，决定是否FullGC来让老年代腾出更多空间。</p>
<h2 id="逃逸分析与栈上分配"><a href="#逃逸分析与栈上分配" class="headerlink" title="逃逸分析与栈上分配"></a>逃逸分析与栈上分配</h2><p><strong>逃逸分析</strong>的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。如果想要StringBuffer sb不逃出方法，可以写成：return sb.toString()；</p>
<h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><p>Sun公司自带了许多虚拟机工具，在bin目录下，其exe文件所依赖的源码在tools.jar包下，利用jar包中的文件可自己开发。</p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java process status<br>可查看本地虚拟机唯一id lvmid (local virtual machine id)：<br><img src="http://ppznxle2c.bkt.clouddn.com/jps.JPG" alt="enter description here"><br>可以加入参数：<br><img src="http://ppznxle2c.bkt.clouddn.com/jpsl.JPG" alt="enter description here"><br>jps -m 运行时传入主类的参数；<br>jps -v 虚拟机参数；<br>jps -l 运行的主类全名 或者jar包名称；<br>也可以一块使用 jsp -mlv。</p>
<h2 id="Jstat"><a href="#Jstat" class="headerlink" title="Jstat"></a>Jstat</h2><p>监视虚拟机运行时的状态信息，包括监视类装载、内存、垃圾回收、jit编译信息。官方文档有操作命令：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p>
<p>jstat -gcutil 3344 1000 10  每隔1000毫秒执行一次 10次<br><img src="http://ppznxle2c.bkt.clouddn.com/Jstat.JPG" alt="enter description here"></p>
<p><em>注：元空间的本质和永久代类似，都是对jvm规范中的方法区的实现。不过元空间与永久代之间最大的区别是：元空间并不在虚拟机中，而是使用本地内存。因此在默认情况下，元空间的大小仅受本地内存限制。</em></p>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>实时查看和调整虚拟机的各项参数<br><img src="http://ppznxle2c.bkt.clouddn.com/Jinfo.JPG" alt="enter description here"><br>第一条指令为：是否启用Serial垃圾回收，输出-，表示不启用；<br>第二条指令为：是否启用G1垃圾回收，输出+，表示启用。</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。<br><em>可实现与-XX:+HeapDumpOnOutOfMemoryError相同的效果</em></p>
<h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>JVM heap Analysis Tool（分析堆）十分占据内存与CPU，使用较少。</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>生成线程快照，定位线程长时间停顿的原因，命令格式为：<br><code>jstack [option] vmid</code></p>
<p>可以通过Thread.getAllStackTraces()方法获取StackTraceElement，来代替jstack方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jstack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Thread, StackTraceElement[]&gt; m = Thread.getAllStackTraces();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Thread, StackTraceElement[]&gt; en:m.entrySet()) &#123;</span><br><span class="line">            Thread t = en.getKey();</span><br><span class="line">            StackTraceElement[] v = en.getValue();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">"Thread name is "</span> + t.getName());</span><br><span class="line">            <span class="keyword">for</span>(StackTraceElement s : v) &#123;</span><br><span class="line">                System.out.println(<span class="string">"\t"</span> + s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>JConsole是一种基于JMX的可视化监视、管理工具可进行内存管理、线程管理、查看死锁等。</p>
<h3 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h3><p>见第一节</p>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/15/java基础拾遗/" rel="next" title="java基础拾遗">
                <i class="fa fa-chevron-left"></i> java基础拾遗
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://ppznxle2c.bkt.clouddn.com/IMG_1547.JPG" alt="Tulong Xiao">
            
              <p class="site-author-name" itemprop="name">Tulong Xiao</p>
              <p class="site-description motion-element" itemprop="description">Almost Famous</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TJtulong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:TJtulong@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/2610493505/home" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/TJtulong" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-book"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.tongji.edu.cn/" title="同济大学" target="_blank">同济大学</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#走近Java"><span class="nav-number">1.</span> <span class="nav-text">走近Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK、JRE与JVM之间的关系："><span class="nav-number">1.1.</span> <span class="nav-text">JDK、JRE与JVM之间的关系：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存溢出的问题及解决"><span class="nav-number">1.2.</span> <span class="nav-text">内存溢出的问题及解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm可视化监控工具"><span class="nav-number">1.3.</span> <span class="nav-text">jvm可视化监控工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的发展"><span class="nav-number">1.4.</span> <span class="nav-text">Java的发展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java技术体系"><span class="nav-number">1.5.</span> <span class="nav-text">java技术体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java虚拟机"><span class="nav-number">1.6.</span> <span class="nav-text">Java虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sun-Classic-VM"><span class="nav-number">1.6.1.</span> <span class="nav-text">Sun Classic VM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exact-VM"><span class="nav-number">1.6.2.</span> <span class="nav-text">Exact VM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot-VM"><span class="nav-number">1.6.3.</span> <span class="nav-text">HotSpot VM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KVM"><span class="nav-number">1.6.4.</span> <span class="nav-text">KVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JRockit"><span class="nav-number">1.6.5.</span> <span class="nav-text">JRockit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#J9"><span class="nav-number">1.6.6.</span> <span class="nav-text">J9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Davik"><span class="nav-number">1.6.7.</span> <span class="nav-text">Davik</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Microsoft-JVM"><span class="nav-number">1.6.8.</span> <span class="nav-text">Microsoft JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Azul-VM-Liquid-VM"><span class="nav-number">1.6.9.</span> <span class="nav-text">Azul VM Liquid VM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Taobao-VM"><span class="nav-number">1.6.10.</span> <span class="nav-text">Taobao VM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java虚拟机的内存管理"><span class="nav-number">2.</span> <span class="nav-text">Java虚拟机的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序计数器"><span class="nav-number">2.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟机栈"><span class="nav-number">2.2.</span> <span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本地方法栈"><span class="nav-number">2.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java堆"><span class="nav-number">2.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法区"><span class="nav-number">2.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时常量池"><span class="nav-number">2.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建"><span class="nav-number">2.7.</span> <span class="nav-text">对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何在堆中给对象分配内存"><span class="nav-number">2.7.1.</span> <span class="nav-text">如何在堆中给对象分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全性问题"><span class="nav-number">2.7.2.</span> <span class="nav-text">线程安全性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的结构"><span class="nav-number">2.8.</span> <span class="nav-text">对象的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">2.9.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收"><span class="nav-number">3.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判定垃圾对象"><span class="nav-number">3.1.</span> <span class="nav-text">判定垃圾对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数算法"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析法"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记清除算法"><span class="nav-number">3.2.1.</span> <span class="nav-text">标记清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法"><span class="nav-number">3.2.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记整理算法"><span class="nav-number">3.2.3.</span> <span class="nav-text">标记整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.2.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial收集器"><span class="nav-number">3.3.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew收集器"><span class="nav-number">3.3.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel收集器"><span class="nav-number">3.3.3.</span> <span class="nav-text">Parallel收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS收集器"><span class="nav-number">3.3.4.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1收集器"><span class="nav-number">3.3.5.</span> <span class="nav-text">G1收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配"><span class="nav-number">4.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Eden区域"><span class="nav-number">4.1.</span> <span class="nav-text">Eden区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大对象直接分配到老年代"><span class="nav-number">4.2.</span> <span class="nav-text">大对象直接分配到老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#长期存活的对象分配到老年代"><span class="nav-number">4.3.</span> <span class="nav-text">长期存活的对象分配到老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空间分配担保"><span class="nav-number">4.4.</span> <span class="nav-text">空间分配担保</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逃逸分析与栈上分配"><span class="nav-number">4.5.</span> <span class="nav-text">逃逸分析与栈上分配</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机工具"><span class="nav-number">5.</span> <span class="nav-text">虚拟机工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jps"><span class="nav-number">5.1.</span> <span class="nav-text">jps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jstat"><span class="nav-number">5.2.</span> <span class="nav-text">Jstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jinfo"><span class="nav-number">5.3.</span> <span class="nav-text">jinfo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jmap"><span class="nav-number">5.4.</span> <span class="nav-text">jmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jhat"><span class="nav-number">5.5.</span> <span class="nav-text">jhat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jstack"><span class="nav-number">5.6.</span> <span class="nav-text">jstack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JConsole"><span class="nav-number">5.7.</span> <span class="nav-text">JConsole</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存监控"><span class="nav-number">5.7.1.</span> <span class="nav-text">内存监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程管理"><span class="nav-number">5.7.2.</span> <span class="nav-text">线程管理</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tulong Xiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
